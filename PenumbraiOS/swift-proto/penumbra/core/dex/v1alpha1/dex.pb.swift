// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: penumbra/core/dex/v1alpha1/dex.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A transaction action that submits a swap to the dex.
struct Penumbra_Core_Dex_V1alpha1_Swap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains the Swap proof.
  var proof: Data = Data()

  /// MockFlowCiphertext dropped until flow encryption/ABCI++ available
  /// // Encrypted amount of asset 1 of the trading pair.
  /// MockFlowCiphertext enc_amount_1 = 2;
  /// // Encrypted amount of asset 2 of the trading pair.
  /// MockFlowCiphertext enc_amount_2 = 3;
  /// Encapsulates the authorized fields of the Swap action, used in signing.
  var body: Penumbra_Core_Dex_V1alpha1_SwapBody {
    get {return _body ?? Penumbra_Core_Dex_V1alpha1_SwapBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {self._body = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _body: Penumbra_Core_Dex_V1alpha1_SwapBody? = nil
}

/// A transaction action that obtains assets previously confirmed
/// via a Swap transaction. Does not include a spend authorization
/// signature, as it is only capable of consuming the NFT from a
/// Swap transaction.
struct Penumbra_Core_Dex_V1alpha1_SwapClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains the SwapClaim proof.
  var proof: Data = Data()

  /// Encapsulates the authorized fields of the SwapClaim action, used in signing.
  var body: Penumbra_Core_Dex_V1alpha1_SwapClaimBody {
    get {return _body ?? Penumbra_Core_Dex_V1alpha1_SwapClaimBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {self._body = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _body: Penumbra_Core_Dex_V1alpha1_SwapClaimBody? = nil
}

/// Encapsulates the authorized fields of the SwapClaim action, used in signing.
struct Penumbra_Core_Dex_V1alpha1_SwapClaimBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nullifier for the Swap NFT to be consumed.
  var nullifier: Penumbra_Core_Crypto_V1alpha1_Nullifier {
    get {return _storage._nullifier ?? Penumbra_Core_Crypto_V1alpha1_Nullifier()}
    set {_uniqueStorage()._nullifier = newValue}
  }
  /// Returns true if `nullifier` has been explicitly set.
  var hasNullifier: Bool {return _storage._nullifier != nil}
  /// Clears the value of `nullifier`. Subsequent reads from it will return its default value.
  mutating func clearNullifier() {_uniqueStorage()._nullifier = nil}

  /// The fee allows `SwapClaim` without an additional `Spend`.
  var fee: Penumbra_Core_Crypto_V1alpha1_Fee {
    get {return _storage._fee ?? Penumbra_Core_Crypto_V1alpha1_Fee()}
    set {_uniqueStorage()._fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  var hasFee: Bool {return _storage._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  mutating func clearFee() {_uniqueStorage()._fee = nil}

  /// Note output for asset 1.
  var output1: Penumbra_Core_Crypto_V1alpha1_NotePayload {
    get {return _storage._output1 ?? Penumbra_Core_Crypto_V1alpha1_NotePayload()}
    set {_uniqueStorage()._output1 = newValue}
  }
  /// Returns true if `output1` has been explicitly set.
  var hasOutput1: Bool {return _storage._output1 != nil}
  /// Clears the value of `output1`. Subsequent reads from it will return its default value.
  mutating func clearOutput1() {_uniqueStorage()._output1 = nil}

  /// Note output for asset 2.
  var output2: Penumbra_Core_Crypto_V1alpha1_NotePayload {
    get {return _storage._output2 ?? Penumbra_Core_Crypto_V1alpha1_NotePayload()}
    set {_uniqueStorage()._output2 = newValue}
  }
  /// Returns true if `output2` has been explicitly set.
  var hasOutput2: Bool {return _storage._output2 != nil}
  /// Clears the value of `output2`. Subsequent reads from it will return its default value.
  mutating func clearOutput2() {_uniqueStorage()._output2 = nil}

  /// Input and output amounts, and asset IDs for the assets in the swap.
  var outputData: Penumbra_Core_Dex_V1alpha1_BatchSwapOutputData {
    get {return _storage._outputData ?? Penumbra_Core_Dex_V1alpha1_BatchSwapOutputData()}
    set {_uniqueStorage()._outputData = newValue}
  }
  /// Returns true if `outputData` has been explicitly set.
  var hasOutputData: Bool {return _storage._outputData != nil}
  /// Clears the value of `outputData`. Subsequent reads from it will return its default value.
  mutating func clearOutputData() {_uniqueStorage()._outputData = nil}

  /// The epoch duration of the chain when the swap claim took place.
  var epochDuration: UInt64 {
    get {return _storage._epochDuration}
    set {_uniqueStorage()._epochDuration = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// For storing the list of claimed swaps between the dex and shielded pool components.
struct Penumbra_Core_Dex_V1alpha1_ClaimedSwapList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var claims: [Penumbra_Core_Dex_V1alpha1_ClaimedSwap] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a swap claimed in a particular transaction.
struct Penumbra_Core_Dex_V1alpha1_ClaimedSwap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var claim: Penumbra_Core_Dex_V1alpha1_SwapClaimBody {
    get {return _claim ?? Penumbra_Core_Dex_V1alpha1_SwapClaimBody()}
    set {_claim = newValue}
  }
  /// Returns true if `claim` has been explicitly set.
  var hasClaim: Bool {return self._claim != nil}
  /// Clears the value of `claim`. Subsequent reads from it will return its default value.
  mutating func clearClaim() {self._claim = nil}

  var txid: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _claim: Penumbra_Core_Dex_V1alpha1_SwapClaimBody? = nil
}

/// The authorized data of a Swap transaction.
struct Penumbra_Core_Dex_V1alpha1_SwapBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The trading pair to swap.
  var tradingPair: Penumbra_Core_Dex_V1alpha1_TradingPair {
    get {return _tradingPair ?? Penumbra_Core_Dex_V1alpha1_TradingPair()}
    set {_tradingPair = newValue}
  }
  /// Returns true if `tradingPair` has been explicitly set.
  var hasTradingPair: Bool {return self._tradingPair != nil}
  /// Clears the value of `tradingPair`. Subsequent reads from it will return its default value.
  mutating func clearTradingPair() {self._tradingPair = nil}

  /// @exclude These will become commitments when flow encryption/ABCI++ are available
  /// The amount for asset 1.
  var delta1I: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _delta1I ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_delta1I = newValue}
  }
  /// Returns true if `delta1I` has been explicitly set.
  var hasDelta1I: Bool {return self._delta1I != nil}
  /// Clears the value of `delta1I`. Subsequent reads from it will return its default value.
  mutating func clearDelta1I() {self._delta1I = nil}

  /// The amount for asset 2.
  var delta2I: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _delta2I ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_delta2I = newValue}
  }
  /// Returns true if `delta2I` has been explicitly set.
  var hasDelta2I: Bool {return self._delta2I != nil}
  /// Clears the value of `delta2I`. Subsequent reads from it will return its default value.
  mutating func clearDelta2I() {self._delta2I = nil}

  /// @exclude // Commitment to the amount for asset 1 (delta 1).
  /// @exclude bytes delta_1_commitment = 2;
  /// @exclude // Commitment to the amount for asset 2 (delta 2).
  /// @exclude bytes delta_2_commitment = 3;
  /// A commitment to a prepaid fee for the future SwapClaim.
  var feeCommitment: Data = Data()

  /// Swap NFT recording the user's contribution.
  var swapNft: Penumbra_Core_Crypto_V1alpha1_NotePayload {
    get {return _swapNft ?? Penumbra_Core_Crypto_V1alpha1_NotePayload()}
    set {_swapNft = newValue}
  }
  /// Returns true if `swapNft` has been explicitly set.
  var hasSwapNft: Bool {return self._swapNft != nil}
  /// Clears the value of `swapNft`. Subsequent reads from it will return its default value.
  mutating func clearSwapNft() {self._swapNft = nil}

  /// Encrypted version of the original `Swap`, symmetrically encrypted w/ viewing key.
  var swapCiphertext: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tradingPair: Penumbra_Core_Dex_V1alpha1_TradingPair? = nil
  fileprivate var _delta1I: Penumbra_Core_Crypto_V1alpha1_Amount? = nil
  fileprivate var _delta2I: Penumbra_Core_Crypto_V1alpha1_Amount? = nil
  fileprivate var _swapNft: Penumbra_Core_Crypto_V1alpha1_NotePayload? = nil
}

struct Penumbra_Core_Dex_V1alpha1_SwapPlaintext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The trading pair to swap.
  var tradingPair: Penumbra_Core_Dex_V1alpha1_TradingPair {
    get {return _tradingPair ?? Penumbra_Core_Dex_V1alpha1_TradingPair()}
    set {_tradingPair = newValue}
  }
  /// Returns true if `tradingPair` has been explicitly set.
  var hasTradingPair: Bool {return self._tradingPair != nil}
  /// Clears the value of `tradingPair`. Subsequent reads from it will return its default value.
  mutating func clearTradingPair() {self._tradingPair = nil}

  /// Input amount of asset 1
  var delta1I: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _delta1I ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_delta1I = newValue}
  }
  /// Returns true if `delta1I` has been explicitly set.
  var hasDelta1I: Bool {return self._delta1I != nil}
  /// Clears the value of `delta1I`. Subsequent reads from it will return its default value.
  mutating func clearDelta1I() {self._delta1I = nil}

  /// Input amount of asset 2
  var delta2I: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _delta2I ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_delta2I = newValue}
  }
  /// Returns true if `delta2I` has been explicitly set.
  var hasDelta2I: Bool {return self._delta2I != nil}
  /// Clears the value of `delta2I`. Subsequent reads from it will return its default value.
  mutating func clearDelta2I() {self._delta2I = nil}

  /// Pre-paid fee to claim the swap
  var claimFee: Penumbra_Core_Crypto_V1alpha1_Fee {
    get {return _claimFee ?? Penumbra_Core_Crypto_V1alpha1_Fee()}
    set {_claimFee = newValue}
  }
  /// Returns true if `claimFee` has been explicitly set.
  var hasClaimFee: Bool {return self._claimFee != nil}
  /// Clears the value of `claimFee`. Subsequent reads from it will return its default value.
  mutating func clearClaimFee() {self._claimFee = nil}

  /// Address that will claim the swap outputs via SwapClaim.
  var claimAddress: Penumbra_Core_Crypto_V1alpha1_Address {
    get {return _claimAddress ?? Penumbra_Core_Crypto_V1alpha1_Address()}
    set {_claimAddress = newValue}
  }
  /// Returns true if `claimAddress` has been explicitly set.
  var hasClaimAddress: Bool {return self._claimAddress != nil}
  /// Clears the value of `claimAddress`. Subsequent reads from it will return its default value.
  mutating func clearClaimAddress() {self._claimAddress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tradingPair: Penumbra_Core_Dex_V1alpha1_TradingPair? = nil
  fileprivate var _delta1I: Penumbra_Core_Crypto_V1alpha1_Amount? = nil
  fileprivate var _delta2I: Penumbra_Core_Crypto_V1alpha1_Amount? = nil
  fileprivate var _claimFee: Penumbra_Core_Crypto_V1alpha1_Fee? = nil
  fileprivate var _claimAddress: Penumbra_Core_Crypto_V1alpha1_Address? = nil
}

struct Penumbra_Core_Dex_V1alpha1_MockFlowCiphertext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Represents this transaction's contribution to flow's value.
  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Holds two asset IDs. Ordering doesn't reflect trading direction, however
/// since the `AssetId` type is `Ord + PartialOrd`, there can be only one
/// `TradingPair` per asset pair.
struct Penumbra_Core_Dex_V1alpha1_TradingPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The first asset of the pair.
  var asset1: Penumbra_Core_Crypto_V1alpha1_AssetId {
    get {return _asset1 ?? Penumbra_Core_Crypto_V1alpha1_AssetId()}
    set {_asset1 = newValue}
  }
  /// Returns true if `asset1` has been explicitly set.
  var hasAsset1: Bool {return self._asset1 != nil}
  /// Clears the value of `asset1`. Subsequent reads from it will return its default value.
  mutating func clearAsset1() {self._asset1 = nil}

  /// The second asset of the pair.
  var asset2: Penumbra_Core_Crypto_V1alpha1_AssetId {
    get {return _asset2 ?? Penumbra_Core_Crypto_V1alpha1_AssetId()}
    set {_asset2 = newValue}
  }
  /// Returns true if `asset2` has been explicitly set.
  var hasAsset2: Bool {return self._asset2 != nil}
  /// Clears the value of `asset2`. Subsequent reads from it will return its default value.
  mutating func clearAsset2() {self._asset2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset1: Penumbra_Core_Crypto_V1alpha1_AssetId? = nil
  fileprivate var _asset2: Penumbra_Core_Crypto_V1alpha1_AssetId? = nil
}

/// Records the result of a batch swap on-chain.
///
/// Used as a public input to a swap claim proof, as it implies the effective
/// clearing price for the batch.
struct Penumbra_Core_Dex_V1alpha1_BatchSwapOutputData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The total amount of asset 1 that was input to the batch swap.
  var delta1: UInt64 = 0

  /// The total amount of asset 2 that was input to the batch swap.
  var delta2: UInt64 = 0

  /// The total amount of asset 1 that was output from the batch swap.
  var lambda1: UInt64 = 0

  /// The total amount of asset 2 that was output from the batch swap.
  var lambda2: UInt64 = 0

  /// Whether the swap succeeded or not.
  var success: Bool = false

  /// The height for which the batch swap data is valid.
  var height: UInt64 = 0

  /// The trading pair associated with the batch swap.
  var tradingPair: Penumbra_Core_Dex_V1alpha1_TradingPair {
    get {return _tradingPair ?? Penumbra_Core_Dex_V1alpha1_TradingPair()}
    set {_tradingPair = newValue}
  }
  /// Returns true if `tradingPair` has been explicitly set.
  var hasTradingPair: Bool {return self._tradingPair != nil}
  /// Clears the value of `tradingPair`. Subsequent reads from it will return its default value.
  mutating func clearTradingPair() {self._tradingPair = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tradingPair: Penumbra_Core_Dex_V1alpha1_TradingPair? = nil
}

/// The data describing a trading function.
///
/// This implicitly treats the trading function as being between assets 1 and 2,
/// without specifying what those assets are, to avoid duplicating data (each
/// asset ID alone is twice the size of the trading function).
///
/// The trading function is `phi(R) = p*R_1 + q*R_2`.
/// This is used as a CFMM with constant `k` and fee `fee` (gamma).
struct Penumbra_Core_Dex_V1alpha1_TradingFunction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: the use of floats here is a placeholder, so we can stub out the
  /// implementation and then decide what type of fixed-point, deterministic
  /// arithmetic should be used.
  var fee: Double = 0

  var k: Double = 0

  var p: Double = 0

  var q: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The reserves of a position.
///
/// Like a position, this implicitly treats the trading function as being
/// between assets 1 and 2, without specifying what those assets are, to avoid
/// duplicating data (each asset ID alone is four times the size of the
/// reserves).
struct Penumbra_Core_Dex_V1alpha1_Reserves {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var r1: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _r1 ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_r1 = newValue}
  }
  /// Returns true if `r1` has been explicitly set.
  var hasR1: Bool {return self._r1 != nil}
  /// Clears the value of `r1`. Subsequent reads from it will return its default value.
  mutating func clearR1() {self._r1 = nil}

  var r2: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _r2 ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_r2 = newValue}
  }
  /// Returns true if `r2` has been explicitly set.
  var hasR2: Bool {return self._r2 != nil}
  /// Clears the value of `r2`. Subsequent reads from it will return its default value.
  mutating func clearR2() {self._r2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _r1: Penumbra_Core_Crypto_V1alpha1_Amount? = nil
  fileprivate var _r2: Penumbra_Core_Crypto_V1alpha1_Amount? = nil
}

/// Data identifying a position.
struct Penumbra_Core_Dex_V1alpha1_Position {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pair: Penumbra_Core_Dex_V1alpha1_TradingPair {
    get {return _pair ?? Penumbra_Core_Dex_V1alpha1_TradingPair()}
    set {_pair = newValue}
  }
  /// Returns true if `pair` has been explicitly set.
  var hasPair: Bool {return self._pair != nil}
  /// Clears the value of `pair`. Subsequent reads from it will return its default value.
  mutating func clearPair() {self._pair = nil}

  var phi: Penumbra_Core_Dex_V1alpha1_TradingFunction {
    get {return _phi ?? Penumbra_Core_Dex_V1alpha1_TradingFunction()}
    set {_phi = newValue}
  }
  /// Returns true if `phi` has been explicitly set.
  var hasPhi: Bool {return self._phi != nil}
  /// Clears the value of `phi`. Subsequent reads from it will return its default value.
  mutating func clearPhi() {self._phi = nil}

  /// A random value used to disambiguate different positions with the exact same
  /// trading function.  The chain should reject newly created positions with the
  /// same nonce as an existing position.  This ensures that `PositionId`s will
  /// be unique, and allows us to track position ownership with a
  /// sequence of stateful NFTs based on the `PositionId`.
  var nonce: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pair: Penumbra_Core_Dex_V1alpha1_TradingPair? = nil
  fileprivate var _phi: Penumbra_Core_Dex_V1alpha1_TradingFunction? = nil
}

/// A hash of a `Position`.
struct Penumbra_Core_Dex_V1alpha1_PositionId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inner: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The state of a position.
struct Penumbra_Core_Dex_V1alpha1_PositionState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Penumbra_Core_Dex_V1alpha1_PositionState.PositionStateEnum = .opened

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PositionStateEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The position has been opened, is active, has reserves and accumulated
    /// fees, and can be traded against.
    case opened // = 0

    /// The position has been closed, is inactive and can no longer be traded
    /// against, but still has reserves and accumulated fees.
    case closed // = 1

    /// The final reserves and accumulated fees have been withdrawn, leaving an
    /// empty, inactive position awaiting (possible) retroactive rewards.
    case withdrawn // = 2

    /// Any retroactive rewards have been claimed. The position is now an inert,
    /// historical artefact.
    case claimed // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .opened
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .opened
      case 1: self = .closed
      case 2: self = .withdrawn
      case 3: self = .claimed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .opened: return 0
      case .closed: return 1
      case .withdrawn: return 2
      case .claimed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Penumbra_Core_Dex_V1alpha1_PositionState.PositionStateEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Penumbra_Core_Dex_V1alpha1_PositionState.PositionStateEnum] = [
    .opened,
    .closed,
    .withdrawn,
    .claimed,
  ]
}

#endif  // swift(>=4.2)

/// An LPNFT tracking both ownership and state of a position.
///
/// Tracking the state as part of the LPNFT means that all LP-related actions can
/// be authorized by spending funds: a state transition (e.g., closing a
/// position) is modeled as spending an "open position LPNFT" and minting a
/// "closed position LPNFT" for the same (globally unique) position ID.
///
/// This means that the LP mechanics can be agnostic to the mechanism used to
/// record custody and spend authorization.  For instance, they can be recorded
/// in the shielded pool, where custody is based on off-chain keys, or they could
/// be recorded in a programmatic on-chain account (in the future, e.g., to
/// support interchain accounts).  This also means that LP-related actions don't
/// require any cryptographic implementation (proofs, signatures, etc), other
/// than hooking into the value commitment mechanism used for transaction
/// balances.
struct Penumbra_Core_Dex_V1alpha1_LpNft {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var positionID: Penumbra_Core_Dex_V1alpha1_PositionId {
    get {return _positionID ?? Penumbra_Core_Dex_V1alpha1_PositionId()}
    set {_positionID = newValue}
  }
  /// Returns true if `positionID` has been explicitly set.
  var hasPositionID: Bool {return self._positionID != nil}
  /// Clears the value of `positionID`. Subsequent reads from it will return its default value.
  mutating func clearPositionID() {self._positionID = nil}

  var state: Penumbra_Core_Dex_V1alpha1_PositionState {
    get {return _state ?? Penumbra_Core_Dex_V1alpha1_PositionState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _positionID: Penumbra_Core_Dex_V1alpha1_PositionId? = nil
  fileprivate var _state: Penumbra_Core_Dex_V1alpha1_PositionState? = nil
}

/// A transaction action that opens a new position.
///
/// This action's contribution to the transaction's value balance is to consume
/// the initial reserves and contribute an opened position NFT.
struct Penumbra_Core_Dex_V1alpha1_PositionOpen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains the data defining the position, sufficient to compute its `PositionId`.
  ///
  /// Positions are immutable, so the `PositionData` (and hence the `PositionId`)
  /// are unchanged over the entire lifetime of the position.
  var position: Penumbra_Core_Dex_V1alpha1_Position {
    get {return _position ?? Penumbra_Core_Dex_V1alpha1_Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  /// The initial reserves of the position.  Unlike the `PositionData`, the
  /// reserves evolve over time as trades are executed against the position.
  var initialReserves: Penumbra_Core_Dex_V1alpha1_Reserves {
    get {return _initialReserves ?? Penumbra_Core_Dex_V1alpha1_Reserves()}
    set {_initialReserves = newValue}
  }
  /// Returns true if `initialReserves` has been explicitly set.
  var hasInitialReserves: Bool {return self._initialReserves != nil}
  /// Clears the value of `initialReserves`. Subsequent reads from it will return its default value.
  mutating func clearInitialReserves() {self._initialReserves = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Penumbra_Core_Dex_V1alpha1_Position? = nil
  fileprivate var _initialReserves: Penumbra_Core_Dex_V1alpha1_Reserves? = nil
}

/// A transaction action that closes a position.
///
/// This action's contribution to the transaction's value balance is to consume
/// an opened position NFT and contribute a closed position NFT.
///
/// Closing a position does not immediately withdraw funds, because Penumbra
/// transactions (like any ZK transaction model) are early-binding: the prover
/// must know the state transition they prove knowledge of, and they cannot know
/// the final reserves with certainty until after the position has been deactivated.
struct Penumbra_Core_Dex_V1alpha1_PositionClose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var positionID: Penumbra_Core_Dex_V1alpha1_PositionId {
    get {return _positionID ?? Penumbra_Core_Dex_V1alpha1_PositionId()}
    set {_positionID = newValue}
  }
  /// Returns true if `positionID` has been explicitly set.
  var hasPositionID: Bool {return self._positionID != nil}
  /// Clears the value of `positionID`. Subsequent reads from it will return its default value.
  mutating func clearPositionID() {self._positionID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _positionID: Penumbra_Core_Dex_V1alpha1_PositionId? = nil
}

/// A transaction action that withdraws funds from a closed position.
///
/// This action's contribution to the transaction's value balance is to consume a
/// closed position NFT and contribute a withdrawn position NFT, as well as all
/// of the funds that were in the position at the time of closing.
struct Penumbra_Core_Dex_V1alpha1_PositionWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var positionID: Penumbra_Core_Dex_V1alpha1_PositionId {
    get {return _positionID ?? Penumbra_Core_Dex_V1alpha1_PositionId()}
    set {_positionID = newValue}
  }
  /// Returns true if `positionID` has been explicitly set.
  var hasPositionID: Bool {return self._positionID != nil}
  /// Clears the value of `positionID`. Subsequent reads from it will return its default value.
  mutating func clearPositionID() {self._positionID = nil}

  /// A transparent (zero blinding factor) commitment to the position's final reserves and fees.
  ///
  /// The chain will check this commitment by recomputing it with the on-chain state.
  var reservesCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment {
    get {return _reservesCommitment ?? Penumbra_Core_Crypto_V1alpha1_BalanceCommitment()}
    set {_reservesCommitment = newValue}
  }
  /// Returns true if `reservesCommitment` has been explicitly set.
  var hasReservesCommitment: Bool {return self._reservesCommitment != nil}
  /// Clears the value of `reservesCommitment`. Subsequent reads from it will return its default value.
  mutating func clearReservesCommitment() {self._reservesCommitment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _positionID: Penumbra_Core_Dex_V1alpha1_PositionId? = nil
  fileprivate var _reservesCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment? = nil
}

/// A transaction action that claims retroactive rewards for a historical
/// position.
///
/// This action's contribution to the transaction's value balance is to consume a
/// withdrawn position NFT and contribute its reward balance.
struct Penumbra_Core_Dex_V1alpha1_PositionRewardClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var positionID: Penumbra_Core_Dex_V1alpha1_PositionId {
    get {return _positionID ?? Penumbra_Core_Dex_V1alpha1_PositionId()}
    set {_positionID = newValue}
  }
  /// Returns true if `positionID` has been explicitly set.
  var hasPositionID: Bool {return self._positionID != nil}
  /// Clears the value of `positionID`. Subsequent reads from it will return its default value.
  mutating func clearPositionID() {self._positionID = nil}

  /// A transparent (zero blinding factor) commitment to the position's accumulated rewards.
  ///
  /// The chain will check this commitment by recomputing it with the on-chain state.
  var rewardsCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment {
    get {return _rewardsCommitment ?? Penumbra_Core_Crypto_V1alpha1_BalanceCommitment()}
    set {_rewardsCommitment = newValue}
  }
  /// Returns true if `rewardsCommitment` has been explicitly set.
  var hasRewardsCommitment: Bool {return self._rewardsCommitment != nil}
  /// Clears the value of `rewardsCommitment`. Subsequent reads from it will return its default value.
  mutating func clearRewardsCommitment() {self._rewardsCommitment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _positionID: Penumbra_Core_Dex_V1alpha1_PositionId? = nil
  fileprivate var _rewardsCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Penumbra_Core_Dex_V1alpha1_Swap: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_SwapClaim: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_SwapClaimBody: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_ClaimedSwapList: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_ClaimedSwap: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_SwapBody: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_SwapPlaintext: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_MockFlowCiphertext: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_TradingPair: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_BatchSwapOutputData: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_TradingFunction: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_Reserves: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_Position: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_PositionId: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_PositionState: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_PositionState.PositionStateEnum: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_LpNft: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_PositionOpen: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_PositionClose: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_PositionWithdraw: @unchecked Sendable {}
extension Penumbra_Core_Dex_V1alpha1_PositionRewardClaim: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "penumbra.core.dex.v1alpha1"

extension Penumbra_Core_Dex_V1alpha1_Swap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Swap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proof"),
    4: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.proof) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.proof.isEmpty {
      try visitor.visitSingularBytesField(value: self.proof, fieldNumber: 1)
    }
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_Swap, rhs: Penumbra_Core_Dex_V1alpha1_Swap) -> Bool {
    if lhs.proof != rhs.proof {return false}
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_SwapClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwapClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proof"),
    2: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.proof) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.proof.isEmpty {
      try visitor.visitSingularBytesField(value: self.proof, fieldNumber: 1)
    }
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_SwapClaim, rhs: Penumbra_Core_Dex_V1alpha1_SwapClaim) -> Bool {
    if lhs.proof != rhs.proof {return false}
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_SwapClaimBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwapClaimBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nullifier"),
    2: .same(proto: "fee"),
    3: .standard(proto: "output_1"),
    4: .standard(proto: "output_2"),
    6: .standard(proto: "output_data"),
    7: .standard(proto: "epoch_duration"),
  ]

  fileprivate class _StorageClass {
    var _nullifier: Penumbra_Core_Crypto_V1alpha1_Nullifier? = nil
    var _fee: Penumbra_Core_Crypto_V1alpha1_Fee? = nil
    var _output1: Penumbra_Core_Crypto_V1alpha1_NotePayload? = nil
    var _output2: Penumbra_Core_Crypto_V1alpha1_NotePayload? = nil
    var _outputData: Penumbra_Core_Dex_V1alpha1_BatchSwapOutputData? = nil
    var _epochDuration: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nullifier = source._nullifier
      _fee = source._fee
      _output1 = source._output1
      _output2 = source._output2
      _outputData = source._outputData
      _epochDuration = source._epochDuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._nullifier) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._fee) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._output1) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._output2) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._outputData) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._epochDuration) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._nullifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._fee {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._output1 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._output2 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._outputData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._epochDuration != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._epochDuration, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_SwapClaimBody, rhs: Penumbra_Core_Dex_V1alpha1_SwapClaimBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nullifier != rhs_storage._nullifier {return false}
        if _storage._fee != rhs_storage._fee {return false}
        if _storage._output1 != rhs_storage._output1 {return false}
        if _storage._output2 != rhs_storage._output2 {return false}
        if _storage._outputData != rhs_storage._outputData {return false}
        if _storage._epochDuration != rhs_storage._epochDuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_ClaimedSwapList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClaimedSwapList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "claims"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.claims) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.claims.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.claims, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_ClaimedSwapList, rhs: Penumbra_Core_Dex_V1alpha1_ClaimedSwapList) -> Bool {
    if lhs.claims != rhs.claims {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_ClaimedSwap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClaimedSwap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "claim"),
    2: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._claim) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._claim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_ClaimedSwap, rhs: Penumbra_Core_Dex_V1alpha1_ClaimedSwap) -> Bool {
    if lhs._claim != rhs._claim {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_SwapBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwapBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trading_pair"),
    2: .standard(proto: "delta_1_i"),
    3: .standard(proto: "delta_2_i"),
    4: .standard(proto: "fee_commitment"),
    5: .standard(proto: "swap_nft"),
    6: .standard(proto: "swap_ciphertext"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tradingPair) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._delta1I) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._delta2I) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.feeCommitment) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._swapNft) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.swapCiphertext) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tradingPair {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._delta1I {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._delta2I {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.feeCommitment.isEmpty {
      try visitor.visitSingularBytesField(value: self.feeCommitment, fieldNumber: 4)
    }
    try { if let v = self._swapNft {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.swapCiphertext.isEmpty {
      try visitor.visitSingularBytesField(value: self.swapCiphertext, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_SwapBody, rhs: Penumbra_Core_Dex_V1alpha1_SwapBody) -> Bool {
    if lhs._tradingPair != rhs._tradingPair {return false}
    if lhs._delta1I != rhs._delta1I {return false}
    if lhs._delta2I != rhs._delta2I {return false}
    if lhs.feeCommitment != rhs.feeCommitment {return false}
    if lhs._swapNft != rhs._swapNft {return false}
    if lhs.swapCiphertext != rhs.swapCiphertext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_SwapPlaintext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwapPlaintext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trading_pair"),
    2: .standard(proto: "delta_1_i"),
    3: .standard(proto: "delta_2_i"),
    4: .standard(proto: "claim_fee"),
    5: .standard(proto: "claim_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tradingPair) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._delta1I) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._delta2I) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._claimFee) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._claimAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tradingPair {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._delta1I {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._delta2I {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._claimFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._claimAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_SwapPlaintext, rhs: Penumbra_Core_Dex_V1alpha1_SwapPlaintext) -> Bool {
    if lhs._tradingPair != rhs._tradingPair {return false}
    if lhs._delta1I != rhs._delta1I {return false}
    if lhs._delta2I != rhs._delta2I {return false}
    if lhs._claimFee != rhs._claimFee {return false}
    if lhs._claimAddress != rhs._claimAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_MockFlowCiphertext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MockFlowCiphertext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_MockFlowCiphertext, rhs: Penumbra_Core_Dex_V1alpha1_MockFlowCiphertext) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_TradingPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_1"),
    2: .standard(proto: "asset_2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asset1) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asset2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asset1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._asset2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_TradingPair, rhs: Penumbra_Core_Dex_V1alpha1_TradingPair) -> Bool {
    if lhs._asset1 != rhs._asset1 {return false}
    if lhs._asset2 != rhs._asset2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_BatchSwapOutputData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchSwapOutputData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delta_1"),
    2: .standard(proto: "delta_2"),
    3: .standard(proto: "lambda_1"),
    4: .standard(proto: "lambda_2"),
    5: .same(proto: "success"),
    6: .same(proto: "height"),
    7: .standard(proto: "trading_pair"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.delta1) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.delta2) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.lambda1) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.lambda2) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._tradingPair) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.delta1 != 0 {
      try visitor.visitSingularUInt64Field(value: self.delta1, fieldNumber: 1)
    }
    if self.delta2 != 0 {
      try visitor.visitSingularUInt64Field(value: self.delta2, fieldNumber: 2)
    }
    if self.lambda1 != 0 {
      try visitor.visitSingularUInt64Field(value: self.lambda1, fieldNumber: 3)
    }
    if self.lambda2 != 0 {
      try visitor.visitSingularUInt64Field(value: self.lambda2, fieldNumber: 4)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 5)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 6)
    }
    try { if let v = self._tradingPair {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_BatchSwapOutputData, rhs: Penumbra_Core_Dex_V1alpha1_BatchSwapOutputData) -> Bool {
    if lhs.delta1 != rhs.delta1 {return false}
    if lhs.delta2 != rhs.delta2 {return false}
    if lhs.lambda1 != rhs.lambda1 {return false}
    if lhs.lambda2 != rhs.lambda2 {return false}
    if lhs.success != rhs.success {return false}
    if lhs.height != rhs.height {return false}
    if lhs._tradingPair != rhs._tradingPair {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_TradingFunction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingFunction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "fee"),
    3: .same(proto: "k"),
    4: .same(proto: "p"),
    5: .same(proto: "q"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.fee) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.k) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.p) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.q) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fee != 0 {
      try visitor.visitSingularDoubleField(value: self.fee, fieldNumber: 2)
    }
    if self.k != 0 {
      try visitor.visitSingularDoubleField(value: self.k, fieldNumber: 3)
    }
    if self.p != 0 {
      try visitor.visitSingularDoubleField(value: self.p, fieldNumber: 4)
    }
    if self.q != 0 {
      try visitor.visitSingularDoubleField(value: self.q, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_TradingFunction, rhs: Penumbra_Core_Dex_V1alpha1_TradingFunction) -> Bool {
    if lhs.fee != rhs.fee {return false}
    if lhs.k != rhs.k {return false}
    if lhs.p != rhs.p {return false}
    if lhs.q != rhs.q {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_Reserves: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reserves"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r1"),
    2: .same(proto: "r2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._r1) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._r2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._r1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._r2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_Reserves, rhs: Penumbra_Core_Dex_V1alpha1_Reserves) -> Bool {
    if lhs._r1 != rhs._r1 {return false}
    if lhs._r2 != rhs._r2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pair"),
    2: .same(proto: "phi"),
    3: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pair) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._phi) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pair {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._phi {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_Position, rhs: Penumbra_Core_Dex_V1alpha1_Position) -> Bool {
    if lhs._pair != rhs._pair {return false}
    if lhs._phi != rhs._phi {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_PositionId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.inner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inner.isEmpty {
      try visitor.visitSingularBytesField(value: self.inner, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_PositionId, rhs: Penumbra_Core_Dex_V1alpha1_PositionId) -> Bool {
    if lhs.inner != rhs.inner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_PositionState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .opened {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_PositionState, rhs: Penumbra_Core_Dex_V1alpha1_PositionState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_PositionState.PositionStateEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPENED"),
    1: .same(proto: "CLOSED"),
    2: .same(proto: "WITHDRAWN"),
    3: .same(proto: "CLAIMED"),
  ]
}

extension Penumbra_Core_Dex_V1alpha1_LpNft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LpNft"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_id"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._positionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._positionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_LpNft, rhs: Penumbra_Core_Dex_V1alpha1_LpNft) -> Bool {
    if lhs._positionID != rhs._positionID {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_PositionOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionOpen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .standard(proto: "initial_reserves"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._initialReserves) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._initialReserves {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_PositionOpen, rhs: Penumbra_Core_Dex_V1alpha1_PositionOpen) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._initialReserves != rhs._initialReserves {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_PositionClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionClose"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._positionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._positionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_PositionClose, rhs: Penumbra_Core_Dex_V1alpha1_PositionClose) -> Bool {
    if lhs._positionID != rhs._positionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_PositionWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_id"),
    2: .standard(proto: "reserves_commitment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._positionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._reservesCommitment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._positionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reservesCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_PositionWithdraw, rhs: Penumbra_Core_Dex_V1alpha1_PositionWithdraw) -> Bool {
    if lhs._positionID != rhs._positionID {return false}
    if lhs._reservesCommitment != rhs._reservesCommitment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Dex_V1alpha1_PositionRewardClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionRewardClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_id"),
    2: .standard(proto: "rewards_commitment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._positionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rewardsCommitment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._positionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rewardsCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_Dex_V1alpha1_PositionRewardClaim, rhs: Penumbra_Core_Dex_V1alpha1_PositionRewardClaim) -> Bool {
    if lhs._positionID != rhs._positionID {return false}
    if lhs._rewardsCommitment != rhs._rewardsCommitment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
