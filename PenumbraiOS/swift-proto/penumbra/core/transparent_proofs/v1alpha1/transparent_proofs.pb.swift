// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: penumbra/core/transparent_proofs/v1alpha1/transparent_proofs.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A Penumbra transparent Spend Proof.
struct Penumbra_Core_TransparentProofs_V1alpha1_SpendProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Auxiliary inputs
  var noteCommitmentProof: Penumbra_Core_Crypto_V1alpha1_NoteCommitmentProof {
    get {return _noteCommitmentProof ?? Penumbra_Core_Crypto_V1alpha1_NoteCommitmentProof()}
    set {_noteCommitmentProof = newValue}
  }
  /// Returns true if `noteCommitmentProof` has been explicitly set.
  var hasNoteCommitmentProof: Bool {return self._noteCommitmentProof != nil}
  /// Clears the value of `noteCommitmentProof`. Subsequent reads from it will return its default value.
  mutating func clearNoteCommitmentProof() {self._noteCommitmentProof = nil}

  ///*
  /// @exclude
  /// From the note being spent
  var note: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _note ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  mutating func clearNote() {self._note = nil}

  var vBlinding: Data = Data()

  var spendAuthRandomizer: Data = Data()

  var ak: Data = Data()

  var nk: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _noteCommitmentProof: Penumbra_Core_Crypto_V1alpha1_NoteCommitmentProof? = nil
  fileprivate var _note: Penumbra_Core_Crypto_V1alpha1_Note? = nil
}

/// A Penumbra transparent output proof.
struct Penumbra_Core_TransparentProofs_V1alpha1_OutputProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Auxiliary inputs
  var note: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _note ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  mutating func clearNote() {self._note = nil}

  var vBlinding: Data = Data()

  var esk: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _note: Penumbra_Core_Crypto_V1alpha1_Note? = nil
}

/// A Penumbra transparent SwapClaimProof.
struct Penumbra_Core_TransparentProofs_V1alpha1_SwapClaimProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// @exclude
  /// Describes the input note with the Swap NFT
  var swapNftAssetID: Data {
    get {return _storage._swapNftAssetID}
    set {_uniqueStorage()._swapNftAssetID = newValue}
  }

  var claimAddress: Penumbra_Core_Crypto_V1alpha1_Address {
    get {return _storage._claimAddress ?? Penumbra_Core_Crypto_V1alpha1_Address()}
    set {_uniqueStorage()._claimAddress = newValue}
  }
  /// Returns true if `claimAddress` has been explicitly set.
  var hasClaimAddress: Bool {return _storage._claimAddress != nil}
  /// Clears the value of `claimAddress`. Subsequent reads from it will return its default value.
  mutating func clearClaimAddress() {_uniqueStorage()._claimAddress = nil}

  /// Inclusion proof for the Swap NFT
  var noteCommitmentProof: Penumbra_Core_Crypto_V1alpha1_NoteCommitmentProof {
    get {return _storage._noteCommitmentProof ?? Penumbra_Core_Crypto_V1alpha1_NoteCommitmentProof()}
    set {_uniqueStorage()._noteCommitmentProof = newValue}
  }
  /// Returns true if `noteCommitmentProof` has been explicitly set.
  var hasNoteCommitmentProof: Bool {return _storage._noteCommitmentProof != nil}
  /// Clears the value of `noteCommitmentProof`. Subsequent reads from it will return its default value.
  mutating func clearNoteCommitmentProof() {_uniqueStorage()._noteCommitmentProof = nil}

  var noteBlinding: Data {
    get {return _storage._noteBlinding}
    set {_uniqueStorage()._noteBlinding = newValue}
  }

  var nk: Data {
    get {return _storage._nk}
    set {_uniqueStorage()._nk = newValue}
  }

  ///*
  /// @exclude
  /// Describes opening of Swap NFT asset ID for commitment verification
  var tradingPair: Penumbra_Core_Dex_V1alpha1_TradingPair {
    get {return _storage._tradingPair ?? Penumbra_Core_Dex_V1alpha1_TradingPair()}
    set {_uniqueStorage()._tradingPair = newValue}
  }
  /// Returns true if `tradingPair` has been explicitly set.
  var hasTradingPair: Bool {return _storage._tradingPair != nil}
  /// Clears the value of `tradingPair`. Subsequent reads from it will return its default value.
  mutating func clearTradingPair() {_uniqueStorage()._tradingPair = nil}

  /// uint64 fee = 7; // fee is public data so not included in client's submitted SwapClaimProof
  /// The user's contribution to the swap
  var delta1I: UInt64 {
    get {return _storage._delta1I}
    set {_uniqueStorage()._delta1I = newValue}
  }

  var delta2I: UInt64 {
    get {return _storage._delta2I}
    set {_uniqueStorage()._delta2I = newValue}
  }

  ///*
  /// @exclude
  /// Describes output amounts
  var lambda1I: UInt64 {
    get {return _storage._lambda1I}
    set {_uniqueStorage()._lambda1I = newValue}
  }

  var lambda2I: UInt64 {
    get {return _storage._lambda2I}
    set {_uniqueStorage()._lambda2I = newValue}
  }

  ///*
  /// @exclude
  /// Describes first output note (lambda 1)
  var noteBlinding1: Data {
    get {return _storage._noteBlinding1}
    set {_uniqueStorage()._noteBlinding1 = newValue}
  }

  var esk1: Data {
    get {return _storage._esk1}
    set {_uniqueStorage()._esk1 = newValue}
  }

  ///*
  /// @exclude
  /// Describes second output note (lambda 2)
  var noteBlinding2: Data {
    get {return _storage._noteBlinding2}
    set {_uniqueStorage()._noteBlinding2 = newValue}
  }

  var esk2: Data {
    get {return _storage._esk2}
    set {_uniqueStorage()._esk2 = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A Penumbra transparent SwapProof.
struct Penumbra_Core_TransparentProofs_V1alpha1_SwapProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Input amount of asset 1
  var delta1: UInt64 = 0

  /// Id of asset 1
  var t1: Data = Data()

  /// Input amount of asset 2
  var delta2: UInt64 = 0

  /// Id of asset 2
  var t2: Data = Data()

  /// Fee
  var fee: Penumbra_Core_Crypto_V1alpha1_Fee {
    get {return _fee ?? Penumbra_Core_Crypto_V1alpha1_Fee()}
    set {_fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  var hasFee: Bool {return self._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  mutating func clearFee() {self._fee = nil}

  /// Fee blinding factor.
  var feeBlinding: Data = Data()

  /// Asset ID of the Swap NFT
  var swapNftAssetID: Data = Data()

  /// Address associated with the swap.
  var claimAddress: Penumbra_Core_Crypto_V1alpha1_Address {
    get {return _claimAddress ?? Penumbra_Core_Crypto_V1alpha1_Address()}
    set {_claimAddress = newValue}
  }
  /// Returns true if `claimAddress` has been explicitly set.
  var hasClaimAddress: Bool {return self._claimAddress != nil}
  /// Clears the value of `claimAddress`. Subsequent reads from it will return its default value.
  mutating func clearClaimAddress() {self._claimAddress = nil}

  /// Note blinding factor
  var noteBlinding: Data = Data()

  /// Ephemeral secret key
  var esk: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fee: Penumbra_Core_Crypto_V1alpha1_Fee? = nil
  fileprivate var _claimAddress: Penumbra_Core_Crypto_V1alpha1_Address? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Penumbra_Core_TransparentProofs_V1alpha1_SpendProof: @unchecked Sendable {}
extension Penumbra_Core_TransparentProofs_V1alpha1_OutputProof: @unchecked Sendable {}
extension Penumbra_Core_TransparentProofs_V1alpha1_SwapClaimProof: @unchecked Sendable {}
extension Penumbra_Core_TransparentProofs_V1alpha1_SwapProof: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "penumbra.core.transparent_proofs.v1alpha1"

extension Penumbra_Core_TransparentProofs_V1alpha1_SpendProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpendProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "note_commitment_proof"),
    2: .same(proto: "note"),
    6: .standard(proto: "v_blinding"),
    9: .standard(proto: "spend_auth_randomizer"),
    10: .same(proto: "ak"),
    11: .same(proto: "nk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._noteCommitmentProof) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.vBlinding) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.spendAuthRandomizer) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.ak) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.nk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._noteCommitmentProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.vBlinding.isEmpty {
      try visitor.visitSingularBytesField(value: self.vBlinding, fieldNumber: 6)
    }
    if !self.spendAuthRandomizer.isEmpty {
      try visitor.visitSingularBytesField(value: self.spendAuthRandomizer, fieldNumber: 9)
    }
    if !self.ak.isEmpty {
      try visitor.visitSingularBytesField(value: self.ak, fieldNumber: 10)
    }
    if !self.nk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nk, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_TransparentProofs_V1alpha1_SpendProof, rhs: Penumbra_Core_TransparentProofs_V1alpha1_SpendProof) -> Bool {
    if lhs._noteCommitmentProof != rhs._noteCommitmentProof {return false}
    if lhs._note != rhs._note {return false}
    if lhs.vBlinding != rhs.vBlinding {return false}
    if lhs.spendAuthRandomizer != rhs.spendAuthRandomizer {return false}
    if lhs.ak != rhs.ak {return false}
    if lhs.nk != rhs.nk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_TransparentProofs_V1alpha1_OutputProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutputProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "note"),
    5: .standard(proto: "v_blinding"),
    7: .same(proto: "esk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.vBlinding) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.esk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.vBlinding.isEmpty {
      try visitor.visitSingularBytesField(value: self.vBlinding, fieldNumber: 5)
    }
    if !self.esk.isEmpty {
      try visitor.visitSingularBytesField(value: self.esk, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_TransparentProofs_V1alpha1_OutputProof, rhs: Penumbra_Core_TransparentProofs_V1alpha1_OutputProof) -> Bool {
    if lhs._note != rhs._note {return false}
    if lhs.vBlinding != rhs.vBlinding {return false}
    if lhs.esk != rhs.esk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_TransparentProofs_V1alpha1_SwapClaimProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwapClaimProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "swap_nft_asset_id"),
    2: .standard(proto: "claim_address"),
    4: .standard(proto: "note_commitment_proof"),
    5: .standard(proto: "note_blinding"),
    6: .same(proto: "nk"),
    10: .standard(proto: "trading_pair"),
    11: .standard(proto: "delta_1_i"),
    12: .standard(proto: "delta_2_i"),
    20: .standard(proto: "lambda_1_i"),
    21: .standard(proto: "lambda_2_i"),
    30: .standard(proto: "note_blinding_1"),
    31: .standard(proto: "esk_1"),
    40: .standard(proto: "note_blinding_2"),
    41: .standard(proto: "esk_2"),
  ]

  fileprivate class _StorageClass {
    var _swapNftAssetID: Data = Data()
    var _claimAddress: Penumbra_Core_Crypto_V1alpha1_Address? = nil
    var _noteCommitmentProof: Penumbra_Core_Crypto_V1alpha1_NoteCommitmentProof? = nil
    var _noteBlinding: Data = Data()
    var _nk: Data = Data()
    var _tradingPair: Penumbra_Core_Dex_V1alpha1_TradingPair? = nil
    var _delta1I: UInt64 = 0
    var _delta2I: UInt64 = 0
    var _lambda1I: UInt64 = 0
    var _lambda2I: UInt64 = 0
    var _noteBlinding1: Data = Data()
    var _esk1: Data = Data()
    var _noteBlinding2: Data = Data()
    var _esk2: Data = Data()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _swapNftAssetID = source._swapNftAssetID
      _claimAddress = source._claimAddress
      _noteCommitmentProof = source._noteCommitmentProof
      _noteBlinding = source._noteBlinding
      _nk = source._nk
      _tradingPair = source._tradingPair
      _delta1I = source._delta1I
      _delta2I = source._delta2I
      _lambda1I = source._lambda1I
      _lambda2I = source._lambda2I
      _noteBlinding1 = source._noteBlinding1
      _esk1 = source._esk1
      _noteBlinding2 = source._noteBlinding2
      _esk2 = source._esk2
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._swapNftAssetID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._claimAddress) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._noteCommitmentProof) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._noteBlinding) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._nk) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._tradingPair) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._delta1I) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._delta2I) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._lambda1I) }()
        case 21: try { try decoder.decodeSingularUInt64Field(value: &_storage._lambda2I) }()
        case 30: try { try decoder.decodeSingularBytesField(value: &_storage._noteBlinding1) }()
        case 31: try { try decoder.decodeSingularBytesField(value: &_storage._esk1) }()
        case 40: try { try decoder.decodeSingularBytesField(value: &_storage._noteBlinding2) }()
        case 41: try { try decoder.decodeSingularBytesField(value: &_storage._esk2) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._swapNftAssetID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._swapNftAssetID, fieldNumber: 1)
      }
      try { if let v = _storage._claimAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._noteCommitmentProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._noteBlinding.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._noteBlinding, fieldNumber: 5)
      }
      if !_storage._nk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nk, fieldNumber: 6)
      }
      try { if let v = _storage._tradingPair {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._delta1I != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._delta1I, fieldNumber: 11)
      }
      if _storage._delta2I != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._delta2I, fieldNumber: 12)
      }
      if _storage._lambda1I != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lambda1I, fieldNumber: 20)
      }
      if _storage._lambda2I != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lambda2I, fieldNumber: 21)
      }
      if !_storage._noteBlinding1.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._noteBlinding1, fieldNumber: 30)
      }
      if !_storage._esk1.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._esk1, fieldNumber: 31)
      }
      if !_storage._noteBlinding2.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._noteBlinding2, fieldNumber: 40)
      }
      if !_storage._esk2.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._esk2, fieldNumber: 41)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_TransparentProofs_V1alpha1_SwapClaimProof, rhs: Penumbra_Core_TransparentProofs_V1alpha1_SwapClaimProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._swapNftAssetID != rhs_storage._swapNftAssetID {return false}
        if _storage._claimAddress != rhs_storage._claimAddress {return false}
        if _storage._noteCommitmentProof != rhs_storage._noteCommitmentProof {return false}
        if _storage._noteBlinding != rhs_storage._noteBlinding {return false}
        if _storage._nk != rhs_storage._nk {return false}
        if _storage._tradingPair != rhs_storage._tradingPair {return false}
        if _storage._delta1I != rhs_storage._delta1I {return false}
        if _storage._delta2I != rhs_storage._delta2I {return false}
        if _storage._lambda1I != rhs_storage._lambda1I {return false}
        if _storage._lambda2I != rhs_storage._lambda2I {return false}
        if _storage._noteBlinding1 != rhs_storage._noteBlinding1 {return false}
        if _storage._esk1 != rhs_storage._esk1 {return false}
        if _storage._noteBlinding2 != rhs_storage._noteBlinding2 {return false}
        if _storage._esk2 != rhs_storage._esk2 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_TransparentProofs_V1alpha1_SwapProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwapProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delta_1"),
    2: .same(proto: "t1"),
    3: .standard(proto: "delta_2"),
    4: .same(proto: "t2"),
    10: .same(proto: "fee"),
    11: .standard(proto: "fee_blinding"),
    30: .standard(proto: "swap_nft_asset_id"),
    40: .standard(proto: "claim_address"),
    42: .standard(proto: "note_blinding"),
    43: .same(proto: "esk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.delta1) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.t1) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.delta2) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.t2) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._fee) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.feeBlinding) }()
      case 30: try { try decoder.decodeSingularBytesField(value: &self.swapNftAssetID) }()
      case 40: try { try decoder.decodeSingularMessageField(value: &self._claimAddress) }()
      case 42: try { try decoder.decodeSingularBytesField(value: &self.noteBlinding) }()
      case 43: try { try decoder.decodeSingularBytesField(value: &self.esk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.delta1 != 0 {
      try visitor.visitSingularUInt64Field(value: self.delta1, fieldNumber: 1)
    }
    if !self.t1.isEmpty {
      try visitor.visitSingularBytesField(value: self.t1, fieldNumber: 2)
    }
    if self.delta2 != 0 {
      try visitor.visitSingularUInt64Field(value: self.delta2, fieldNumber: 3)
    }
    if !self.t2.isEmpty {
      try visitor.visitSingularBytesField(value: self.t2, fieldNumber: 4)
    }
    try { if let v = self._fee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if !self.feeBlinding.isEmpty {
      try visitor.visitSingularBytesField(value: self.feeBlinding, fieldNumber: 11)
    }
    if !self.swapNftAssetID.isEmpty {
      try visitor.visitSingularBytesField(value: self.swapNftAssetID, fieldNumber: 30)
    }
    try { if let v = self._claimAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    } }()
    if !self.noteBlinding.isEmpty {
      try visitor.visitSingularBytesField(value: self.noteBlinding, fieldNumber: 42)
    }
    if !self.esk.isEmpty {
      try visitor.visitSingularBytesField(value: self.esk, fieldNumber: 43)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_Core_TransparentProofs_V1alpha1_SwapProof, rhs: Penumbra_Core_TransparentProofs_V1alpha1_SwapProof) -> Bool {
    if lhs.delta1 != rhs.delta1 {return false}
    if lhs.t1 != rhs.t1 {return false}
    if lhs.delta2 != rhs.delta2 {return false}
    if lhs.t2 != rhs.t2 {return false}
    if lhs._fee != rhs._fee {return false}
    if lhs.feeBlinding != rhs.feeBlinding {return false}
    if lhs.swapNftAssetID != rhs.swapNftAssetID {return false}
    if lhs._claimAddress != rhs._claimAddress {return false}
    if lhs.noteBlinding != rhs.noteBlinding {return false}
    if lhs.esk != rhs.esk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
