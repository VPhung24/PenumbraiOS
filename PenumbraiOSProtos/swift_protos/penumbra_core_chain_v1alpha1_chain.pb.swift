// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: penumbra/core/chain/v1alpha1/chain.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Global chain configuration data, such as chain ID, epoch duration, etc.
public struct Penumbra_Core_Chain_V1alpha1_ChainParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier of the chain.
  public var chainID: String {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  /// The duration of each epoch, in number of blocks.
  public var epochDuration: UInt64 {
    get {return _storage._epochDuration}
    set {_uniqueStorage()._epochDuration = newValue}
  }

  /// The number of epochs an unbonding note for before being released.
  public var unbondingEpochs: UInt64 {
    get {return _storage._unbondingEpochs}
    set {_uniqueStorage()._unbondingEpochs = newValue}
  }

  /// The maximum number of validators in the consensus set.
  public var activeValidatorLimit: UInt64 {
    get {return _storage._activeValidatorLimit}
    set {_uniqueStorage()._activeValidatorLimit = newValue}
  }

  /// The base reward rate, expressed in basis points of basis points
  public var baseRewardRate: UInt64 {
    get {return _storage._baseRewardRate}
    set {_uniqueStorage()._baseRewardRate = newValue}
  }

  /// The penalty for slashing due to misbehavior, expressed in basis points.
  public var slashingPenaltyMisbehaviorBps: UInt64 {
    get {return _storage._slashingPenaltyMisbehaviorBps}
    set {_uniqueStorage()._slashingPenaltyMisbehaviorBps = newValue}
  }

  /// The penalty for slashing due to downtime, expressed in basis points.
  public var slashingPenaltyDowntimeBps: UInt64 {
    get {return _storage._slashingPenaltyDowntimeBps}
    set {_uniqueStorage()._slashingPenaltyDowntimeBps = newValue}
  }

  /// The number of blocks in the window to check for downtime.
  public var signedBlocksWindowLen: UInt64 {
    get {return _storage._signedBlocksWindowLen}
    set {_uniqueStorage()._signedBlocksWindowLen = newValue}
  }

  /// The maximum number of blocks in the window each validator can miss signing without slashing.
  public var missedBlocksMaximum: UInt64 {
    get {return _storage._missedBlocksMaximum}
    set {_uniqueStorage()._missedBlocksMaximum = newValue}
  }

  /// Whether IBC (forming connections, processing IBC packets) is enabled.
  public var ibcEnabled: Bool {
    get {return _storage._ibcEnabled}
    set {_uniqueStorage()._ibcEnabled = newValue}
  }

  /// Whether inbound ICS-20 transfers are enabled
  public var inboundIcs20TransfersEnabled: Bool {
    get {return _storage._inboundIcs20TransfersEnabled}
    set {_uniqueStorage()._inboundIcs20TransfersEnabled = newValue}
  }

  /// Whether outbound ICS-20 transfers are enabled
  public var outboundIcs20TransfersEnabled: Bool {
    get {return _storage._outboundIcs20TransfersEnabled}
    set {_uniqueStorage()._outboundIcs20TransfersEnabled = newValue}
  }

  /// The number of blocks during which a proposal is voted on.
  public var proposalVotingBlocks: UInt64 {
    get {return _storage._proposalVotingBlocks}
    set {_uniqueStorage()._proposalVotingBlocks = newValue}
  }

  /// The deposit required to create a proposal.
  public var proposalDepositAmount: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _storage._proposalDepositAmount ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_uniqueStorage()._proposalDepositAmount = newValue}
  }
  /// Returns true if `proposalDepositAmount` has been explicitly set.
  public var hasProposalDepositAmount: Bool {return _storage._proposalDepositAmount != nil}
  /// Clears the value of `proposalDepositAmount`. Subsequent reads from it will return its default value.
  public mutating func clearProposalDepositAmount() {_uniqueStorage()._proposalDepositAmount = nil}

  /// The quorum required for a proposal to be considered valid, as a fraction of the total stake
  /// weight of the network.
  public var proposalValidQuorum: Penumbra_Core_Chain_V1alpha1_Ratio {
    get {return _storage._proposalValidQuorum ?? Penumbra_Core_Chain_V1alpha1_Ratio()}
    set {_uniqueStorage()._proposalValidQuorum = newValue}
  }
  /// Returns true if `proposalValidQuorum` has been explicitly set.
  public var hasProposalValidQuorum: Bool {return _storage._proposalValidQuorum != nil}
  /// Clears the value of `proposalValidQuorum`. Subsequent reads from it will return its default value.
  public mutating func clearProposalValidQuorum() {_uniqueStorage()._proposalValidQuorum = nil}

  /// The threshold for a proposal to pass voting, as a ratio of "yes" votes over "no" votes.
  public var proposalPassThreshold: Penumbra_Core_Chain_V1alpha1_Ratio {
    get {return _storage._proposalPassThreshold ?? Penumbra_Core_Chain_V1alpha1_Ratio()}
    set {_uniqueStorage()._proposalPassThreshold = newValue}
  }
  /// Returns true if `proposalPassThreshold` has been explicitly set.
  public var hasProposalPassThreshold: Bool {return _storage._proposalPassThreshold != nil}
  /// Clears the value of `proposalPassThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearProposalPassThreshold() {_uniqueStorage()._proposalPassThreshold = nil}

  /// The threshold for a proposal to be vetoed, regardless of whether the "yes" and "no" votes would
  /// have passed it, as a ratio of "no with veto" votes over all total votes.
  public var proposalVetoThreshold: Penumbra_Core_Chain_V1alpha1_Ratio {
    get {return _storage._proposalVetoThreshold ?? Penumbra_Core_Chain_V1alpha1_Ratio()}
    set {_uniqueStorage()._proposalVetoThreshold = newValue}
  }
  /// Returns true if `proposalVetoThreshold` has been explicitly set.
  public var hasProposalVetoThreshold: Bool {return _storage._proposalVetoThreshold != nil}
  /// Clears the value of `proposalVetoThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearProposalVetoThreshold() {_uniqueStorage()._proposalVetoThreshold = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The ratio between two numbers, used in governance to describe vote thresholds and quorums.
public struct Penumbra_Core_Chain_V1alpha1_Ratio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The numerator.
  public var numerator: UInt64 = 0

  /// The denominator.
  public var denominator: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Parameters for Fuzzy Message Detection
public struct Penumbra_Core_Chain_V1alpha1_FmdParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var precisionBits: UInt32 = 0

  public var asOfBlockHeight: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TODO: delete with legacy code
/// Information about a given asset at a given time (as specified by block
/// height). Currently this only contains the total supply.
public struct Penumbra_Core_Chain_V1alpha1_AssetInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assetID: Penumbra_Core_Crypto_V1alpha1_AssetId {
    get {return _assetID ?? Penumbra_Core_Crypto_V1alpha1_AssetId()}
    set {_assetID = newValue}
  }
  /// Returns true if `assetID` has been explicitly set.
  public var hasAssetID: Bool {return self._assetID != nil}
  /// Clears the value of `assetID`. Subsequent reads from it will return its default value.
  public mutating func clearAssetID() {self._assetID = nil}

  public var denom: Penumbra_Core_Crypto_V1alpha1_Denom {
    get {return _denom ?? Penumbra_Core_Crypto_V1alpha1_Denom()}
    set {_denom = newValue}
  }
  /// Returns true if `denom` has been explicitly set.
  public var hasDenom: Bool {return self._denom != nil}
  /// Clears the value of `denom`. Subsequent reads from it will return its default value.
  public mutating func clearDenom() {self._denom = nil}

  public var asOfBlockHeight: UInt64 = 0

  public var totalSupply: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _assetID: Penumbra_Core_Crypto_V1alpha1_AssetId?
  fileprivate var _denom: Penumbra_Core_Crypto_V1alpha1_Denom?
}

/// Contains the minimum data needed to update client state.
public struct Penumbra_Core_Chain_V1alpha1_CompactBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  /// NotePayloads describing new notes.
  public var notePayloads: [Penumbra_Core_Chain_V1alpha1_AnnotatedNotePayload] = []

  /// Nullifiers identifying spent notes.
  public var nullifiers: [Penumbra_Core_Crypto_V1alpha1_Nullifier] = []

  /// The block root of this block.
  public var blockRoot: Penumbra_Core_Crypto_V1alpha1_MerkleRoot {
    get {return _blockRoot ?? Penumbra_Core_Crypto_V1alpha1_MerkleRoot()}
    set {_blockRoot = newValue}
  }
  /// Returns true if `blockRoot` has been explicitly set.
  public var hasBlockRoot: Bool {return self._blockRoot != nil}
  /// Clears the value of `blockRoot`. Subsequent reads from it will return its default value.
  public mutating func clearBlockRoot() {self._blockRoot = nil}

  /// The epoch root of this epoch (only present when the block is the last in an epoch).
  public var epochRoot: Penumbra_Core_Crypto_V1alpha1_MerkleRoot {
    get {return _epochRoot ?? Penumbra_Core_Crypto_V1alpha1_MerkleRoot()}
    set {_epochRoot = newValue}
  }
  /// Returns true if `epochRoot` has been explicitly set.
  public var hasEpochRoot: Bool {return self._epochRoot != nil}
  /// Clears the value of `epochRoot`. Subsequent reads from it will return its default value.
  public mutating func clearEpochRoot() {self._epochRoot = nil}

  /// Newly quarantined things in this block.
  public var quarantined: Penumbra_Core_Chain_V1alpha1_Quarantined {
    get {return _quarantined ?? Penumbra_Core_Chain_V1alpha1_Quarantined()}
    set {_quarantined = newValue}
  }
  /// Returns true if `quarantined` has been explicitly set.
  public var hasQuarantined: Bool {return self._quarantined != nil}
  /// Clears the value of `quarantined`. Subsequent reads from it will return its default value.
  public mutating func clearQuarantined() {self._quarantined = nil}

  /// Validators slashed in this block.
  public var slashed: [Penumbra_Core_Crypto_V1alpha1_IdentityKey] = []

  /// If a proposal started voting in this block, this is set to `true`.
  public var proposalStarted: Bool = false

  /// Latest Fuzzy Message Detection parameters.
  public var fmdParameters: Penumbra_Core_Chain_V1alpha1_FmdParameters {
    get {return _fmdParameters ?? Penumbra_Core_Chain_V1alpha1_FmdParameters()}
    set {_fmdParameters = newValue}
  }
  /// Returns true if `fmdParameters` has been explicitly set.
  public var hasFmdParameters: Bool {return self._fmdParameters != nil}
  /// Clears the value of `fmdParameters`. Subsequent reads from it will return its default value.
  public mutating func clearFmdParameters() {self._fmdParameters = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _blockRoot: Penumbra_Core_Crypto_V1alpha1_MerkleRoot?
  fileprivate var _epochRoot: Penumbra_Core_Crypto_V1alpha1_MerkleRoot?
  fileprivate var _quarantined: Penumbra_Core_Chain_V1alpha1_Quarantined?
  fileprivate var _fmdParameters: Penumbra_Core_Chain_V1alpha1_FmdParameters?
}

/// A note payload, annotated with the note source.
public struct Penumbra_Core_Chain_V1alpha1_AnnotatedNotePayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Penumbra_Core_Crypto_V1alpha1_NotePayload {
    get {return _payload ?? Penumbra_Core_Crypto_V1alpha1_NotePayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var source: Penumbra_Core_Chain_V1alpha1_NoteSource {
    get {return _source ?? Penumbra_Core_Chain_V1alpha1_NoteSource()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Penumbra_Core_Crypto_V1alpha1_NotePayload?
  fileprivate var _source: Penumbra_Core_Chain_V1alpha1_NoteSource?
}

public struct Penumbra_Core_Chain_V1alpha1_KnownAssets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assets: [Penumbra_Core_Crypto_V1alpha1_Asset] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A spicy transaction ID
public struct Penumbra_Core_Chain_V1alpha1_NoteSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inner: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A spicier transaction ID: one which can be missing
public struct Penumbra_Core_Chain_V1alpha1_DelibleNoteSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var source: Penumbra_Core_Chain_V1alpha1_NoteSource {
    get {return _source ?? Penumbra_Core_Chain_V1alpha1_NoteSource()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Penumbra_Core_Chain_V1alpha1_NoteSource?
}

public struct Penumbra_Core_Chain_V1alpha1_GenesisAppState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chainParams: Penumbra_Core_Chain_V1alpha1_ChainParameters {
    get {return _chainParams ?? Penumbra_Core_Chain_V1alpha1_ChainParameters()}
    set {_chainParams = newValue}
  }
  /// Returns true if `chainParams` has been explicitly set.
  public var hasChainParams: Bool {return self._chainParams != nil}
  /// Clears the value of `chainParams`. Subsequent reads from it will return its default value.
  public mutating func clearChainParams() {self._chainParams = nil}

  public var validators: [Penumbra_Core_Stake_V1alpha1_Validator] = []

  public var allocations: [Penumbra_Core_Chain_V1alpha1_GenesisAppState.Allocation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Allocation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var amount: UInt64 = 0

    public var denom: String = String()

    public var address: Penumbra_Core_Crypto_V1alpha1_Address {
      get {return _address ?? Penumbra_Core_Crypto_V1alpha1_Address()}
      set {_address = newValue}
    }
    /// Returns true if `address` has been explicitly set.
    public var hasAddress: Bool {return self._address != nil}
    /// Clears the value of `address`. Subsequent reads from it will return its default value.
    public mutating func clearAddress() {self._address = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _address: Penumbra_Core_Crypto_V1alpha1_Address?
  }

  public init() {}

  fileprivate var _chainParams: Penumbra_Core_Chain_V1alpha1_ChainParameters?
}

public struct Penumbra_Core_Chain_V1alpha1_Quarantined {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var perEpoch: [Penumbra_Core_Chain_V1alpha1_Quarantined.EpochEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Unbonding {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var notePayloads: [Penumbra_Core_Chain_V1alpha1_AnnotatedNotePayload] = []

    public var nullifiers: [Penumbra_Core_Crypto_V1alpha1_Nullifier] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ValidatorEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey {
      get {return _identityKey ?? Penumbra_Core_Crypto_V1alpha1_IdentityKey()}
      set {_identityKey = newValue}
    }
    /// Returns true if `identityKey` has been explicitly set.
    public var hasIdentityKey: Bool {return self._identityKey != nil}
    /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
    public mutating func clearIdentityKey() {self._identityKey = nil}

    public var unbonding: Penumbra_Core_Chain_V1alpha1_Quarantined.Unbonding {
      get {return _unbonding ?? Penumbra_Core_Chain_V1alpha1_Quarantined.Unbonding()}
      set {_unbonding = newValue}
    }
    /// Returns true if `unbonding` has been explicitly set.
    public var hasUnbonding: Bool {return self._unbonding != nil}
    /// Clears the value of `unbonding`. Subsequent reads from it will return its default value.
    public mutating func clearUnbonding() {self._unbonding = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey?
    fileprivate var _unbonding: Penumbra_Core_Chain_V1alpha1_Quarantined.Unbonding?
  }

  public struct Scheduled {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var perValidator: [Penumbra_Core_Chain_V1alpha1_Quarantined.ValidatorEntry] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct EpochEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unbondingEpoch: UInt64 = 0

    public var scheduled: Penumbra_Core_Chain_V1alpha1_Quarantined.Scheduled {
      get {return _scheduled ?? Penumbra_Core_Chain_V1alpha1_Quarantined.Scheduled()}
      set {_scheduled = newValue}
    }
    /// Returns true if `scheduled` has been explicitly set.
    public var hasScheduled: Bool {return self._scheduled != nil}
    /// Clears the value of `scheduled`. Subsequent reads from it will return its default value.
    public mutating func clearScheduled() {self._scheduled = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _scheduled: Penumbra_Core_Chain_V1alpha1_Quarantined.Scheduled?
  }

  public init() {}
}

public struct Penumbra_Core_Chain_V1alpha1_Slashed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var validators: [Penumbra_Core_Crypto_V1alpha1_IdentityKey] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Penumbra_Core_Chain_V1alpha1_ChainParameters: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_Ratio: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_FmdParameters: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_AssetInfo: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_CompactBlock: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_AnnotatedNotePayload: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_KnownAssets: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_NoteSource: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_DelibleNoteSource: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_GenesisAppState: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_GenesisAppState.Allocation: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_Quarantined: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_Quarantined.Unbonding: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_Quarantined.ValidatorEntry: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_Quarantined.Scheduled: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_Quarantined.EpochEntry: @unchecked Sendable {}
extension Penumbra_Core_Chain_V1alpha1_Slashed: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "penumbra.core.chain.v1alpha1"

extension Penumbra_Core_Chain_V1alpha1_ChainParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChainParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .standard(proto: "epoch_duration"),
    3: .standard(proto: "unbonding_epochs"),
    4: .standard(proto: "active_validator_limit"),
    9: .standard(proto: "base_reward_rate"),
    5: .standard(proto: "slashing_penalty_misbehavior_bps"),
    10: .standard(proto: "slashing_penalty_downtime_bps"),
    11: .standard(proto: "signed_blocks_window_len"),
    12: .standard(proto: "missed_blocks_maximum"),
    6: .standard(proto: "ibc_enabled"),
    7: .standard(proto: "inbound_ics20_transfers_enabled"),
    8: .standard(proto: "outbound_ics20_transfers_enabled"),
    20: .standard(proto: "proposal_voting_blocks"),
    21: .standard(proto: "proposal_deposit_amount"),
    22: .standard(proto: "proposal_valid_quorum"),
    23: .standard(proto: "proposal_pass_threshold"),
    24: .standard(proto: "proposal_veto_threshold"),
  ]

  fileprivate class _StorageClass {
    var _chainID: String = String()
    var _epochDuration: UInt64 = 0
    var _unbondingEpochs: UInt64 = 0
    var _activeValidatorLimit: UInt64 = 0
    var _baseRewardRate: UInt64 = 0
    var _slashingPenaltyMisbehaviorBps: UInt64 = 0
    var _slashingPenaltyDowntimeBps: UInt64 = 0
    var _signedBlocksWindowLen: UInt64 = 0
    var _missedBlocksMaximum: UInt64 = 0
    var _ibcEnabled: Bool = false
    var _inboundIcs20TransfersEnabled: Bool = false
    var _outboundIcs20TransfersEnabled: Bool = false
    var _proposalVotingBlocks: UInt64 = 0
    var _proposalDepositAmount: Penumbra_Core_Crypto_V1alpha1_Amount?
    var _proposalValidQuorum: Penumbra_Core_Chain_V1alpha1_Ratio?
    var _proposalPassThreshold: Penumbra_Core_Chain_V1alpha1_Ratio?
    var _proposalVetoThreshold: Penumbra_Core_Chain_V1alpha1_Ratio?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chainID = source._chainID
      _epochDuration = source._epochDuration
      _unbondingEpochs = source._unbondingEpochs
      _activeValidatorLimit = source._activeValidatorLimit
      _baseRewardRate = source._baseRewardRate
      _slashingPenaltyMisbehaviorBps = source._slashingPenaltyMisbehaviorBps
      _slashingPenaltyDowntimeBps = source._slashingPenaltyDowntimeBps
      _signedBlocksWindowLen = source._signedBlocksWindowLen
      _missedBlocksMaximum = source._missedBlocksMaximum
      _ibcEnabled = source._ibcEnabled
      _inboundIcs20TransfersEnabled = source._inboundIcs20TransfersEnabled
      _outboundIcs20TransfersEnabled = source._outboundIcs20TransfersEnabled
      _proposalVotingBlocks = source._proposalVotingBlocks
      _proposalDepositAmount = source._proposalDepositAmount
      _proposalValidQuorum = source._proposalValidQuorum
      _proposalPassThreshold = source._proposalPassThreshold
      _proposalVetoThreshold = source._proposalVetoThreshold
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._chainID) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._epochDuration) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._unbondingEpochs) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._activeValidatorLimit) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._slashingPenaltyMisbehaviorBps) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._ibcEnabled) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._inboundIcs20TransfersEnabled) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._outboundIcs20TransfersEnabled) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._baseRewardRate) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._slashingPenaltyDowntimeBps) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._signedBlocksWindowLen) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._missedBlocksMaximum) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._proposalVotingBlocks) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._proposalDepositAmount) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._proposalValidQuorum) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._proposalPassThreshold) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._proposalVetoThreshold) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._chainID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chainID, fieldNumber: 1)
      }
      if _storage._epochDuration != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._epochDuration, fieldNumber: 2)
      }
      if _storage._unbondingEpochs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._unbondingEpochs, fieldNumber: 3)
      }
      if _storage._activeValidatorLimit != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._activeValidatorLimit, fieldNumber: 4)
      }
      if _storage._slashingPenaltyMisbehaviorBps != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._slashingPenaltyMisbehaviorBps, fieldNumber: 5)
      }
      if _storage._ibcEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._ibcEnabled, fieldNumber: 6)
      }
      if _storage._inboundIcs20TransfersEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._inboundIcs20TransfersEnabled, fieldNumber: 7)
      }
      if _storage._outboundIcs20TransfersEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._outboundIcs20TransfersEnabled, fieldNumber: 8)
      }
      if _storage._baseRewardRate != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._baseRewardRate, fieldNumber: 9)
      }
      if _storage._slashingPenaltyDowntimeBps != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._slashingPenaltyDowntimeBps, fieldNumber: 10)
      }
      if _storage._signedBlocksWindowLen != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._signedBlocksWindowLen, fieldNumber: 11)
      }
      if _storage._missedBlocksMaximum != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._missedBlocksMaximum, fieldNumber: 12)
      }
      if _storage._proposalVotingBlocks != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._proposalVotingBlocks, fieldNumber: 20)
      }
      try { if let v = _storage._proposalDepositAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._proposalValidQuorum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._proposalPassThreshold {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._proposalVetoThreshold {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_ChainParameters, rhs: Penumbra_Core_Chain_V1alpha1_ChainParameters) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chainID != rhs_storage._chainID {return false}
        if _storage._epochDuration != rhs_storage._epochDuration {return false}
        if _storage._unbondingEpochs != rhs_storage._unbondingEpochs {return false}
        if _storage._activeValidatorLimit != rhs_storage._activeValidatorLimit {return false}
        if _storage._baseRewardRate != rhs_storage._baseRewardRate {return false}
        if _storage._slashingPenaltyMisbehaviorBps != rhs_storage._slashingPenaltyMisbehaviorBps {return false}
        if _storage._slashingPenaltyDowntimeBps != rhs_storage._slashingPenaltyDowntimeBps {return false}
        if _storage._signedBlocksWindowLen != rhs_storage._signedBlocksWindowLen {return false}
        if _storage._missedBlocksMaximum != rhs_storage._missedBlocksMaximum {return false}
        if _storage._ibcEnabled != rhs_storage._ibcEnabled {return false}
        if _storage._inboundIcs20TransfersEnabled != rhs_storage._inboundIcs20TransfersEnabled {return false}
        if _storage._outboundIcs20TransfersEnabled != rhs_storage._outboundIcs20TransfersEnabled {return false}
        if _storage._proposalVotingBlocks != rhs_storage._proposalVotingBlocks {return false}
        if _storage._proposalDepositAmount != rhs_storage._proposalDepositAmount {return false}
        if _storage._proposalValidQuorum != rhs_storage._proposalValidQuorum {return false}
        if _storage._proposalPassThreshold != rhs_storage._proposalPassThreshold {return false}
        if _storage._proposalVetoThreshold != rhs_storage._proposalVetoThreshold {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_Ratio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ratio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numerator"),
    2: .same(proto: "denominator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.numerator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.denominator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numerator != 0 {
      try visitor.visitSingularUInt64Field(value: self.numerator, fieldNumber: 1)
    }
    if self.denominator != 0 {
      try visitor.visitSingularUInt64Field(value: self.denominator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_Ratio, rhs: Penumbra_Core_Chain_V1alpha1_Ratio) -> Bool {
    if lhs.numerator != rhs.numerator {return false}
    if lhs.denominator != rhs.denominator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_FmdParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FmdParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "precision_bits"),
    2: .standard(proto: "as_of_block_height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.precisionBits) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.asOfBlockHeight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.precisionBits != 0 {
      try visitor.visitSingularUInt32Field(value: self.precisionBits, fieldNumber: 1)
    }
    if self.asOfBlockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.asOfBlockHeight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_FmdParameters, rhs: Penumbra_Core_Chain_V1alpha1_FmdParameters) -> Bool {
    if lhs.precisionBits != rhs.precisionBits {return false}
    if lhs.asOfBlockHeight != rhs.asOfBlockHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_AssetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .same(proto: "denom"),
    3: .standard(proto: "as_of_block_height"),
    4: .standard(proto: "total_supply"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._assetID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._denom) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.asOfBlockHeight) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.totalSupply) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._assetID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._denom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.asOfBlockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.asOfBlockHeight, fieldNumber: 3)
    }
    if self.totalSupply != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalSupply, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_AssetInfo, rhs: Penumbra_Core_Chain_V1alpha1_AssetInfo) -> Bool {
    if lhs._assetID != rhs._assetID {return false}
    if lhs._denom != rhs._denom {return false}
    if lhs.asOfBlockHeight != rhs.asOfBlockHeight {return false}
    if lhs.totalSupply != rhs.totalSupply {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_CompactBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompactBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .standard(proto: "note_payloads"),
    3: .same(proto: "nullifiers"),
    4: .standard(proto: "block_root"),
    5: .standard(proto: "epoch_root"),
    6: .same(proto: "quarantined"),
    16: .same(proto: "slashed"),
    20: .standard(proto: "proposal_started"),
    100: .standard(proto: "fmd_parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.notePayloads) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nullifiers) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._blockRoot) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._epochRoot) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._quarantined) }()
      case 16: try { try decoder.decodeRepeatedMessageField(value: &self.slashed) }()
      case 20: try { try decoder.decodeSingularBoolField(value: &self.proposalStarted) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._fmdParameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if !self.notePayloads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notePayloads, fieldNumber: 2)
    }
    if !self.nullifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nullifiers, fieldNumber: 3)
    }
    try { if let v = self._blockRoot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._epochRoot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._quarantined {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.slashed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slashed, fieldNumber: 16)
    }
    if self.proposalStarted != false {
      try visitor.visitSingularBoolField(value: self.proposalStarted, fieldNumber: 20)
    }
    try { if let v = self._fmdParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_CompactBlock, rhs: Penumbra_Core_Chain_V1alpha1_CompactBlock) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.notePayloads != rhs.notePayloads {return false}
    if lhs.nullifiers != rhs.nullifiers {return false}
    if lhs._blockRoot != rhs._blockRoot {return false}
    if lhs._epochRoot != rhs._epochRoot {return false}
    if lhs._quarantined != rhs._quarantined {return false}
    if lhs.slashed != rhs.slashed {return false}
    if lhs.proposalStarted != rhs.proposalStarted {return false}
    if lhs._fmdParameters != rhs._fmdParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_AnnotatedNotePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotatedNotePayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_AnnotatedNotePayload, rhs: Penumbra_Core_Chain_V1alpha1_AnnotatedNotePayload) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs._source != rhs._source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_KnownAssets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KnownAssets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_KnownAssets, rhs: Penumbra_Core_Chain_V1alpha1_KnownAssets) -> Bool {
    if lhs.assets != rhs.assets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_NoteSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoteSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inner"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.inner) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inner.isEmpty {
      try visitor.visitSingularBytesField(value: self.inner, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_NoteSource, rhs: Penumbra_Core_Chain_V1alpha1_NoteSource) -> Bool {
    if lhs.inner != rhs.inner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_DelibleNoteSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelibleNoteSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_DelibleNoteSource, rhs: Penumbra_Core_Chain_V1alpha1_DelibleNoteSource) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_GenesisAppState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenesisAppState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_params"),
    2: .same(proto: "validators"),
    3: .same(proto: "allocations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chainParams) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.allocations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chainParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 2)
    }
    if !self.allocations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allocations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_GenesisAppState, rhs: Penumbra_Core_Chain_V1alpha1_GenesisAppState) -> Bool {
    if lhs._chainParams != rhs._chainParams {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.allocations != rhs.allocations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_GenesisAppState.Allocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Chain_V1alpha1_GenesisAppState.protoMessageName + ".Allocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "denom"),
    3: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_GenesisAppState.Allocation, rhs: Penumbra_Core_Chain_V1alpha1_GenesisAppState.Allocation) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_Quarantined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Quarantined"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "per_epoch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.perEpoch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.perEpoch.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.perEpoch, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_Quarantined, rhs: Penumbra_Core_Chain_V1alpha1_Quarantined) -> Bool {
    if lhs.perEpoch != rhs.perEpoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_Quarantined.Unbonding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Chain_V1alpha1_Quarantined.protoMessageName + ".Unbonding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "note_payloads"),
    2: .same(proto: "nullifiers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notePayloads) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nullifiers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notePayloads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notePayloads, fieldNumber: 1)
    }
    if !self.nullifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nullifiers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_Quarantined.Unbonding, rhs: Penumbra_Core_Chain_V1alpha1_Quarantined.Unbonding) -> Bool {
    if lhs.notePayloads != rhs.notePayloads {return false}
    if lhs.nullifiers != rhs.nullifiers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_Quarantined.ValidatorEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Chain_V1alpha1_Quarantined.protoMessageName + ".ValidatorEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "identity_key"),
    2: .same(proto: "unbonding"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identityKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._unbonding) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identityKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unbonding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_Quarantined.ValidatorEntry, rhs: Penumbra_Core_Chain_V1alpha1_Quarantined.ValidatorEntry) -> Bool {
    if lhs._identityKey != rhs._identityKey {return false}
    if lhs._unbonding != rhs._unbonding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_Quarantined.Scheduled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Chain_V1alpha1_Quarantined.protoMessageName + ".Scheduled"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "per_validator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.perValidator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.perValidator.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.perValidator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_Quarantined.Scheduled, rhs: Penumbra_Core_Chain_V1alpha1_Quarantined.Scheduled) -> Bool {
    if lhs.perValidator != rhs.perValidator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_Quarantined.EpochEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Chain_V1alpha1_Quarantined.protoMessageName + ".EpochEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unbonding_epoch"),
    2: .same(proto: "scheduled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.unbondingEpoch) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scheduled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.unbondingEpoch != 0 {
      try visitor.visitSingularUInt64Field(value: self.unbondingEpoch, fieldNumber: 1)
    }
    try { if let v = self._scheduled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_Quarantined.EpochEntry, rhs: Penumbra_Core_Chain_V1alpha1_Quarantined.EpochEntry) -> Bool {
    if lhs.unbondingEpoch != rhs.unbondingEpoch {return false}
    if lhs._scheduled != rhs._scheduled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Chain_V1alpha1_Slashed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Slashed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validators"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Chain_V1alpha1_Slashed, rhs: Penumbra_Core_Chain_V1alpha1_Slashed) -> Bool {
    if lhs.validators != rhs.validators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
