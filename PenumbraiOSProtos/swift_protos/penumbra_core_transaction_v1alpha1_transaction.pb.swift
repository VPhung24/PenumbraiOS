// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: penumbra/core/transaction/v1alpha1/transaction.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An authorization hash for a Penumbra transaction.
public struct Penumbra_Core_Transaction_V1alpha1_AuthHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inner: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Penumbra transaction.
public struct Penumbra_Core_Transaction_V1alpha1_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: Penumbra_Core_Transaction_V1alpha1_TransactionBody {
    get {return _body ?? Penumbra_Core_Transaction_V1alpha1_TransactionBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {self._body = nil}

  /// The binding signature is stored separately from the transaction body that it signs.
  public var bindingSig: Data = Data()

  /// The root of some previous state of the note commitment tree, used as an anchor for all
  /// ZK state transition proofs.
  public var anchor: Penumbra_Core_Crypto_V1alpha1_MerkleRoot {
    get {return _anchor ?? Penumbra_Core_Crypto_V1alpha1_MerkleRoot()}
    set {_anchor = newValue}
  }
  /// Returns true if `anchor` has been explicitly set.
  public var hasAnchor: Bool {return self._anchor != nil}
  /// Clears the value of `anchor`. Subsequent reads from it will return its default value.
  public mutating func clearAnchor() {self._anchor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _body: Penumbra_Core_Transaction_V1alpha1_TransactionBody?
  fileprivate var _anchor: Penumbra_Core_Crypto_V1alpha1_MerkleRoot?
}

/// The body of a transaction.
public struct Penumbra_Core_Transaction_V1alpha1_TransactionBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of actions (state changes) performed by this transaction.
  public var actions: [Penumbra_Core_Transaction_V1alpha1_Action] = []

  /// The maximum height that this transaction can be included in the chain.
  ///
  /// If zero, there is no maximum.
  public var expiryHeight: UInt64 = 0

  /// The chain this transaction is intended for.  Including this prevents
  /// replaying a transaction on one chain onto a different chain.
  public var chainID: String = String()

  /// The transaction fee.
  public var fee: Penumbra_Core_Crypto_V1alpha1_Fee {
    get {return _fee ?? Penumbra_Core_Crypto_V1alpha1_Fee()}
    set {_fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  public var hasFee: Bool {return self._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  public mutating func clearFee() {self._fee = nil}

  /// A list of clues for use with Fuzzy Message Detection.
  public var fmdClues: [Penumbra_Core_Crypto_V1alpha1_Clue] = []

  /// An optional encrypted memo. It will only be populated if there are
  /// outputs in the actions of this transaction. 528 bytes.
  public var encryptedMemo: Data {
    get {return _encryptedMemo ?? Data()}
    set {_encryptedMemo = newValue}
  }
  /// Returns true if `encryptedMemo` has been explicitly set.
  public var hasEncryptedMemo: Bool {return self._encryptedMemo != nil}
  /// Clears the value of `encryptedMemo`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptedMemo() {self._encryptedMemo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fee: Penumbra_Core_Crypto_V1alpha1_Fee?
  fileprivate var _encryptedMemo: Data?
}

/// A state change performed by a transaction.
public struct Penumbra_Core_Transaction_V1alpha1_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Penumbra_Core_Transaction_V1alpha1_Action.OneOf_Action?

  public var spend: Penumbra_Core_Transaction_V1alpha1_Spend {
    get {
      if case .spend(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_Spend()
    }
    set {action = .spend(newValue)}
  }

  public var output: Penumbra_Core_Transaction_V1alpha1_Output {
    get {
      if case .output(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_Output()
    }
    set {action = .output(newValue)}
  }

  public var delegate: Penumbra_Core_Stake_V1alpha1_Delegate {
    get {
      if case .delegate(let v)? = action {return v}
      return Penumbra_Core_Stake_V1alpha1_Delegate()
    }
    set {action = .delegate(newValue)}
  }

  public var undelegate: Penumbra_Core_Stake_V1alpha1_Undelegate {
    get {
      if case .undelegate(let v)? = action {return v}
      return Penumbra_Core_Stake_V1alpha1_Undelegate()
    }
    set {action = .undelegate(newValue)}
  }

  public var swap: Penumbra_Core_Dex_V1alpha1_Swap {
    get {
      if case .swap(let v)? = action {return v}
      return Penumbra_Core_Dex_V1alpha1_Swap()
    }
    set {action = .swap(newValue)}
  }

  public var swapClaim: Penumbra_Core_Dex_V1alpha1_SwapClaim {
    get {
      if case .swapClaim(let v)? = action {return v}
      return Penumbra_Core_Dex_V1alpha1_SwapClaim()
    }
    set {action = .swapClaim(newValue)}
  }

  public var validatorDefinition: Penumbra_Core_Stake_V1alpha1_ValidatorDefinition {
    get {
      if case .validatorDefinition(let v)? = action {return v}
      return Penumbra_Core_Stake_V1alpha1_ValidatorDefinition()
    }
    set {action = .validatorDefinition(newValue)}
  }

  public var ibcAction: Penumbra_Core_Ibc_V1alpha1_IbcAction {
    get {
      if case .ibcAction(let v)? = action {return v}
      return Penumbra_Core_Ibc_V1alpha1_IbcAction()
    }
    set {action = .ibcAction(newValue)}
  }

  /// Governance:
  public var proposalSubmit: Penumbra_Core_Transaction_V1alpha1_ProposalSubmit {
    get {
      if case .proposalSubmit(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_ProposalSubmit()
    }
    set {action = .proposalSubmit(newValue)}
  }

  public var proposalWithdraw: Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw {
    get {
      if case .proposalWithdraw(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw()
    }
    set {action = .proposalWithdraw(newValue)}
  }

  /// DelegatorVote delegator_vote = 21;
  public var validatorVote: Penumbra_Core_Transaction_V1alpha1_ValidatorVote {
    get {
      if case .validatorVote(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_ValidatorVote()
    }
    set {action = .validatorVote(newValue)}
  }

  public var positionOpen: Penumbra_Core_Dex_V1alpha1_PositionOpen {
    get {
      if case .positionOpen(let v)? = action {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionOpen()
    }
    set {action = .positionOpen(newValue)}
  }

  public var positionClose: Penumbra_Core_Dex_V1alpha1_PositionClose {
    get {
      if case .positionClose(let v)? = action {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionClose()
    }
    set {action = .positionClose(newValue)}
  }

  public var positionWithdraw: Penumbra_Core_Dex_V1alpha1_PositionWithdraw {
    get {
      if case .positionWithdraw(let v)? = action {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionWithdraw()
    }
    set {action = .positionWithdraw(newValue)}
  }

  public var positionRewardClaim: Penumbra_Core_Dex_V1alpha1_PositionRewardClaim {
    get {
      if case .positionRewardClaim(let v)? = action {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionRewardClaim()
    }
    set {action = .positionRewardClaim(newValue)}
  }

  public var ics20Withdrawal: Penumbra_Core_Ibc_V1alpha1_Ics20Withdrawal {
    get {
      if case .ics20Withdrawal(let v)? = action {return v}
      return Penumbra_Core_Ibc_V1alpha1_Ics20Withdrawal()
    }
    set {action = .ics20Withdrawal(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable {
    case spend(Penumbra_Core_Transaction_V1alpha1_Spend)
    case output(Penumbra_Core_Transaction_V1alpha1_Output)
    case delegate(Penumbra_Core_Stake_V1alpha1_Delegate)
    case undelegate(Penumbra_Core_Stake_V1alpha1_Undelegate)
    case swap(Penumbra_Core_Dex_V1alpha1_Swap)
    case swapClaim(Penumbra_Core_Dex_V1alpha1_SwapClaim)
    case validatorDefinition(Penumbra_Core_Stake_V1alpha1_ValidatorDefinition)
    case ibcAction(Penumbra_Core_Ibc_V1alpha1_IbcAction)
    /// Governance:
    case proposalSubmit(Penumbra_Core_Transaction_V1alpha1_ProposalSubmit)
    case proposalWithdraw(Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw)
    /// DelegatorVote delegator_vote = 21;
    case validatorVote(Penumbra_Core_Transaction_V1alpha1_ValidatorVote)
    case positionOpen(Penumbra_Core_Dex_V1alpha1_PositionOpen)
    case positionClose(Penumbra_Core_Dex_V1alpha1_PositionClose)
    case positionWithdraw(Penumbra_Core_Dex_V1alpha1_PositionWithdraw)
    case positionRewardClaim(Penumbra_Core_Dex_V1alpha1_PositionRewardClaim)
    case ics20Withdrawal(Penumbra_Core_Ibc_V1alpha1_Ics20Withdrawal)

  #if !swift(>=4.1)
    public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Action.OneOf_Action, rhs: Penumbra_Core_Transaction_V1alpha1_Action.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.spend, .spend): return {
        guard case .spend(let l) = lhs, case .spend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.output, .output): return {
        guard case .output(let l) = lhs, case .output(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delegate, .delegate): return {
        guard case .delegate(let l) = lhs, case .delegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.undelegate, .undelegate): return {
        guard case .undelegate(let l) = lhs, case .undelegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.swap, .swap): return {
        guard case .swap(let l) = lhs, case .swap(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.swapClaim, .swapClaim): return {
        guard case .swapClaim(let l) = lhs, case .swapClaim(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.validatorDefinition, .validatorDefinition): return {
        guard case .validatorDefinition(let l) = lhs, case .validatorDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ibcAction, .ibcAction): return {
        guard case .ibcAction(let l) = lhs, case .ibcAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proposalSubmit, .proposalSubmit): return {
        guard case .proposalSubmit(let l) = lhs, case .proposalSubmit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proposalWithdraw, .proposalWithdraw): return {
        guard case .proposalWithdraw(let l) = lhs, case .proposalWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.validatorVote, .validatorVote): return {
        guard case .validatorVote(let l) = lhs, case .validatorVote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionOpen, .positionOpen): return {
        guard case .positionOpen(let l) = lhs, case .positionOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionClose, .positionClose): return {
        guard case .positionClose(let l) = lhs, case .positionClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionWithdraw, .positionWithdraw): return {
        guard case .positionWithdraw(let l) = lhs, case .positionWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionRewardClaim, .positionRewardClaim): return {
        guard case .positionRewardClaim(let l) = lhs, case .positionRewardClaim(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ics20Withdrawal, .ics20Withdrawal): return {
        guard case .ics20Withdrawal(let l) = lhs, case .ics20Withdrawal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Penumbra_Core_Transaction_V1alpha1_TransactionPerspective {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payloadKeys: [Penumbra_Core_Transaction_V1alpha1_PayloadKeyWithCommitment] = []

  public var spendNullifiers: [Penumbra_Core_Transaction_V1alpha1_NullifierWithNote] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Penumbra_Core_Transaction_V1alpha1_PayloadKeyWithCommitment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payloadKey: Data = Data()

  public var commitment: Penumbra_Core_Crypto_V1alpha1_NoteCommitment {
    get {return _commitment ?? Penumbra_Core_Crypto_V1alpha1_NoteCommitment()}
    set {_commitment = newValue}
  }
  /// Returns true if `commitment` has been explicitly set.
  public var hasCommitment: Bool {return self._commitment != nil}
  /// Clears the value of `commitment`. Subsequent reads from it will return its default value.
  public mutating func clearCommitment() {self._commitment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commitment: Penumbra_Core_Crypto_V1alpha1_NoteCommitment?
}

public struct Penumbra_Core_Transaction_V1alpha1_NullifierWithNote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nullifier: Penumbra_Core_Crypto_V1alpha1_Nullifier {
    get {return _nullifier ?? Penumbra_Core_Crypto_V1alpha1_Nullifier()}
    set {_nullifier = newValue}
  }
  /// Returns true if `nullifier` has been explicitly set.
  public var hasNullifier: Bool {return self._nullifier != nil}
  /// Clears the value of `nullifier`. Subsequent reads from it will return its default value.
  public mutating func clearNullifier() {self._nullifier = nil}

  public var note: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _note ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nullifier: Penumbra_Core_Crypto_V1alpha1_Nullifier?
  fileprivate var _note: Penumbra_Core_Crypto_V1alpha1_Note?
}

public struct Penumbra_Core_Transaction_V1alpha1_TransactionView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list views into of actions (state changes) performed by this transaction.
  public var actionViews: [Penumbra_Core_Transaction_V1alpha1_ActionView] = []

  /// The maximum height that this transaction can be included in the chain.
  ///
  /// If zero, there is no maximum.
  public var expiryHeight: UInt64 = 0

  /// The chain this transaction is intended for.  Including this prevents
  /// replaying a transaction on one chain onto a different chain.
  public var chainID: String = String()

  /// The transaction fee.
  public var fee: Penumbra_Core_Crypto_V1alpha1_Fee {
    get {return _fee ?? Penumbra_Core_Crypto_V1alpha1_Fee()}
    set {_fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  public var hasFee: Bool {return self._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  public mutating func clearFee() {self._fee = nil}

  /// A list of clues for use with Fuzzy Message Detection.
  public var fmdClues: [Penumbra_Core_Crypto_V1alpha1_Clue] = []

  /// An optional plaintext memo. It will only be populated if there are
  /// outputs in the actions of this transaction.
  public var memo: String {
    get {return _memo ?? String()}
    set {_memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  public var hasMemo: Bool {return self._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  public mutating func clearMemo() {self._memo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fee: Penumbra_Core_Crypto_V1alpha1_Fee?
  fileprivate var _memo: String?
}

public struct Penumbra_Core_Transaction_V1alpha1_SpendView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var spend: Penumbra_Core_Transaction_V1alpha1_Spend {
    get {return _spend ?? Penumbra_Core_Transaction_V1alpha1_Spend()}
    set {_spend = newValue}
  }
  /// Returns true if `spend` has been explicitly set.
  public var hasSpend: Bool {return self._spend != nil}
  /// Clears the value of `spend`. Subsequent reads from it will return its default value.
  public mutating func clearSpend() {self._spend = nil}

  public var note: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _note ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spend: Penumbra_Core_Transaction_V1alpha1_Spend?
  fileprivate var _note: Penumbra_Core_Crypto_V1alpha1_Note?
}

public struct Penumbra_Core_Transaction_V1alpha1_OutputView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var output: Penumbra_Core_Transaction_V1alpha1_Output {
    get {return _output ?? Penumbra_Core_Transaction_V1alpha1_Output()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {self._output = nil}

  public var note: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _note ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  public var payloadKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _output: Penumbra_Core_Transaction_V1alpha1_Output?
  fileprivate var _note: Penumbra_Core_Crypto_V1alpha1_Note?
}

public struct Penumbra_Core_Transaction_V1alpha1_SwapView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var swap: Penumbra_Core_Dex_V1alpha1_Swap {
    get {return _storage._swap ?? Penumbra_Core_Dex_V1alpha1_Swap()}
    set {_uniqueStorage()._swap = newValue}
  }
  /// Returns true if `swap` has been explicitly set.
  public var hasSwap: Bool {return _storage._swap != nil}
  /// Clears the value of `swap`. Subsequent reads from it will return its default value.
  public mutating func clearSwap() {_uniqueStorage()._swap = nil}

  public var swapNft: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _storage._swapNft ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_uniqueStorage()._swapNft = newValue}
  }
  /// Returns true if `swapNft` has been explicitly set.
  public var hasSwapNft: Bool {return _storage._swapNft != nil}
  /// Clears the value of `swapNft`. Subsequent reads from it will return its default value.
  public mutating func clearSwapNft() {_uniqueStorage()._swapNft = nil}

  public var swapPlaintext: Penumbra_Core_Dex_V1alpha1_SwapPlaintext {
    get {return _storage._swapPlaintext ?? Penumbra_Core_Dex_V1alpha1_SwapPlaintext()}
    set {_uniqueStorage()._swapPlaintext = newValue}
  }
  /// Returns true if `swapPlaintext` has been explicitly set.
  public var hasSwapPlaintext: Bool {return _storage._swapPlaintext != nil}
  /// Clears the value of `swapPlaintext`. Subsequent reads from it will return its default value.
  public mutating func clearSwapPlaintext() {_uniqueStorage()._swapPlaintext = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Penumbra_Core_Transaction_V1alpha1_SwapClaimView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var swapClaim: Penumbra_Core_Dex_V1alpha1_SwapClaim {
    get {return _swapClaim ?? Penumbra_Core_Dex_V1alpha1_SwapClaim()}
    set {_swapClaim = newValue}
  }
  /// Returns true if `swapClaim` has been explicitly set.
  public var hasSwapClaim: Bool {return self._swapClaim != nil}
  /// Clears the value of `swapClaim`. Subsequent reads from it will return its default value.
  public mutating func clearSwapClaim() {self._swapClaim = nil}

  public var output1: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _output1 ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_output1 = newValue}
  }
  /// Returns true if `output1` has been explicitly set.
  public var hasOutput1: Bool {return self._output1 != nil}
  /// Clears the value of `output1`. Subsequent reads from it will return its default value.
  public mutating func clearOutput1() {self._output1 = nil}

  public var output2: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _output2 ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_output2 = newValue}
  }
  /// Returns true if `output2` has been explicitly set.
  public var hasOutput2: Bool {return self._output2 != nil}
  /// Clears the value of `output2`. Subsequent reads from it will return its default value.
  public mutating func clearOutput2() {self._output2 = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _swapClaim: Penumbra_Core_Dex_V1alpha1_SwapClaim?
  fileprivate var _output1: Penumbra_Core_Crypto_V1alpha1_Note?
  fileprivate var _output2: Penumbra_Core_Crypto_V1alpha1_Note?
}

/// A view of a specific state change action performed by a transaction.
public struct Penumbra_Core_Transaction_V1alpha1_ActionView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionView: Penumbra_Core_Transaction_V1alpha1_ActionView.OneOf_ActionView?

  public var spend: Penumbra_Core_Transaction_V1alpha1_SpendView {
    get {
      if case .spend(let v)? = actionView {return v}
      return Penumbra_Core_Transaction_V1alpha1_SpendView()
    }
    set {actionView = .spend(newValue)}
  }

  public var output: Penumbra_Core_Transaction_V1alpha1_OutputView {
    get {
      if case .output(let v)? = actionView {return v}
      return Penumbra_Core_Transaction_V1alpha1_OutputView()
    }
    set {actionView = .output(newValue)}
  }

  public var delegate: Penumbra_Core_Stake_V1alpha1_Delegate {
    get {
      if case .delegate(let v)? = actionView {return v}
      return Penumbra_Core_Stake_V1alpha1_Delegate()
    }
    set {actionView = .delegate(newValue)}
  }

  public var undelegate: Penumbra_Core_Stake_V1alpha1_Undelegate {
    get {
      if case .undelegate(let v)? = actionView {return v}
      return Penumbra_Core_Stake_V1alpha1_Undelegate()
    }
    set {actionView = .undelegate(newValue)}
  }

  public var swap: Penumbra_Core_Transaction_V1alpha1_SwapView {
    get {
      if case .swap(let v)? = actionView {return v}
      return Penumbra_Core_Transaction_V1alpha1_SwapView()
    }
    set {actionView = .swap(newValue)}
  }

  public var swapClaim: Penumbra_Core_Transaction_V1alpha1_SwapClaimView {
    get {
      if case .swapClaim(let v)? = actionView {return v}
      return Penumbra_Core_Transaction_V1alpha1_SwapClaimView()
    }
    set {actionView = .swapClaim(newValue)}
  }

  public var validatorDefinition: Penumbra_Core_Stake_V1alpha1_ValidatorDefinition {
    get {
      if case .validatorDefinition(let v)? = actionView {return v}
      return Penumbra_Core_Stake_V1alpha1_ValidatorDefinition()
    }
    set {actionView = .validatorDefinition(newValue)}
  }

  public var ibcAction: Penumbra_Core_Ibc_V1alpha1_IbcAction {
    get {
      if case .ibcAction(let v)? = actionView {return v}
      return Penumbra_Core_Ibc_V1alpha1_IbcAction()
    }
    set {actionView = .ibcAction(newValue)}
  }

  /// Governance:
  public var proposalSubmit: Penumbra_Core_Transaction_V1alpha1_ProposalSubmit {
    get {
      if case .proposalSubmit(let v)? = actionView {return v}
      return Penumbra_Core_Transaction_V1alpha1_ProposalSubmit()
    }
    set {actionView = .proposalSubmit(newValue)}
  }

  public var proposalWithdraw: Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw {
    get {
      if case .proposalWithdraw(let v)? = actionView {return v}
      return Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw()
    }
    set {actionView = .proposalWithdraw(newValue)}
  }

  /// DelegatorVote delegator_vote = 21;
  public var validatorVote: Penumbra_Core_Transaction_V1alpha1_ValidatorVote {
    get {
      if case .validatorVote(let v)? = actionView {return v}
      return Penumbra_Core_Transaction_V1alpha1_ValidatorVote()
    }
    set {actionView = .validatorVote(newValue)}
  }

  public var positionOpen: Penumbra_Core_Dex_V1alpha1_PositionOpen {
    get {
      if case .positionOpen(let v)? = actionView {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionOpen()
    }
    set {actionView = .positionOpen(newValue)}
  }

  public var positionClose: Penumbra_Core_Dex_V1alpha1_PositionClose {
    get {
      if case .positionClose(let v)? = actionView {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionClose()
    }
    set {actionView = .positionClose(newValue)}
  }

  public var positionWithdraw: Penumbra_Core_Dex_V1alpha1_PositionWithdraw {
    get {
      if case .positionWithdraw(let v)? = actionView {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionWithdraw()
    }
    set {actionView = .positionWithdraw(newValue)}
  }

  public var positionRewardClaim: Penumbra_Core_Dex_V1alpha1_PositionRewardClaim {
    get {
      if case .positionRewardClaim(let v)? = actionView {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionRewardClaim()
    }
    set {actionView = .positionRewardClaim(newValue)}
  }

  public var ics20Withdrawal: Penumbra_Core_Ibc_V1alpha1_Ics20Withdrawal {
    get {
      if case .ics20Withdrawal(let v)? = actionView {return v}
      return Penumbra_Core_Ibc_V1alpha1_Ics20Withdrawal()
    }
    set {actionView = .ics20Withdrawal(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ActionView: Equatable {
    case spend(Penumbra_Core_Transaction_V1alpha1_SpendView)
    case output(Penumbra_Core_Transaction_V1alpha1_OutputView)
    case delegate(Penumbra_Core_Stake_V1alpha1_Delegate)
    case undelegate(Penumbra_Core_Stake_V1alpha1_Undelegate)
    case swap(Penumbra_Core_Transaction_V1alpha1_SwapView)
    case swapClaim(Penumbra_Core_Transaction_V1alpha1_SwapClaimView)
    case validatorDefinition(Penumbra_Core_Stake_V1alpha1_ValidatorDefinition)
    case ibcAction(Penumbra_Core_Ibc_V1alpha1_IbcAction)
    /// Governance:
    case proposalSubmit(Penumbra_Core_Transaction_V1alpha1_ProposalSubmit)
    case proposalWithdraw(Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw)
    /// DelegatorVote delegator_vote = 21;
    case validatorVote(Penumbra_Core_Transaction_V1alpha1_ValidatorVote)
    case positionOpen(Penumbra_Core_Dex_V1alpha1_PositionOpen)
    case positionClose(Penumbra_Core_Dex_V1alpha1_PositionClose)
    case positionWithdraw(Penumbra_Core_Dex_V1alpha1_PositionWithdraw)
    case positionRewardClaim(Penumbra_Core_Dex_V1alpha1_PositionRewardClaim)
    case ics20Withdrawal(Penumbra_Core_Ibc_V1alpha1_Ics20Withdrawal)

  #if !swift(>=4.1)
    public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_ActionView.OneOf_ActionView, rhs: Penumbra_Core_Transaction_V1alpha1_ActionView.OneOf_ActionView) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.spend, .spend): return {
        guard case .spend(let l) = lhs, case .spend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.output, .output): return {
        guard case .output(let l) = lhs, case .output(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delegate, .delegate): return {
        guard case .delegate(let l) = lhs, case .delegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.undelegate, .undelegate): return {
        guard case .undelegate(let l) = lhs, case .undelegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.swap, .swap): return {
        guard case .swap(let l) = lhs, case .swap(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.swapClaim, .swapClaim): return {
        guard case .swapClaim(let l) = lhs, case .swapClaim(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.validatorDefinition, .validatorDefinition): return {
        guard case .validatorDefinition(let l) = lhs, case .validatorDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ibcAction, .ibcAction): return {
        guard case .ibcAction(let l) = lhs, case .ibcAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proposalSubmit, .proposalSubmit): return {
        guard case .proposalSubmit(let l) = lhs, case .proposalSubmit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proposalWithdraw, .proposalWithdraw): return {
        guard case .proposalWithdraw(let l) = lhs, case .proposalWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.validatorVote, .validatorVote): return {
        guard case .validatorVote(let l) = lhs, case .validatorVote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionOpen, .positionOpen): return {
        guard case .positionOpen(let l) = lhs, case .positionOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionClose, .positionClose): return {
        guard case .positionClose(let l) = lhs, case .positionClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionWithdraw, .positionWithdraw): return {
        guard case .positionWithdraw(let l) = lhs, case .positionWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionRewardClaim, .positionRewardClaim): return {
        guard case .positionRewardClaim(let l) = lhs, case .positionRewardClaim(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ics20Withdrawal, .ics20Withdrawal): return {
        guard case .ics20Withdrawal(let l) = lhs, case .ics20Withdrawal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Spends a shielded note.
public struct Penumbra_Core_Transaction_V1alpha1_Spend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The authorizing data for the spend, which is included in the authorization hash used for signing.
  public var body: Penumbra_Core_Transaction_V1alpha1_SpendBody {
    get {return _body ?? Penumbra_Core_Transaction_V1alpha1_SpendBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {self._body = nil}

  /// The spend authorization signature is effecting data.
  public var authSig: Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature {
    get {return _authSig ?? Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature()}
    set {_authSig = newValue}
  }
  /// Returns true if `authSig` has been explicitly set.
  public var hasAuthSig: Bool {return self._authSig != nil}
  /// Clears the value of `authSig`. Subsequent reads from it will return its default value.
  public mutating func clearAuthSig() {self._authSig = nil}

  /// The spend proof is effecting data.
  public var proof: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _body: Penumbra_Core_Transaction_V1alpha1_SpendBody?
  fileprivate var _authSig: Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature?
}

/// The body of a spend description, containing only the "authorizing" data
/// included in the authorization hash used for signing, and not the "effecting"
/// data which is bound to the authorizing data by some other means.
public struct Penumbra_Core_Transaction_V1alpha1_SpendBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A commitment to the value of the input note.
  public var balanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment {
    get {return _balanceCommitment ?? Penumbra_Core_Crypto_V1alpha1_BalanceCommitment()}
    set {_balanceCommitment = newValue}
  }
  /// Returns true if `balanceCommitment` has been explicitly set.
  public var hasBalanceCommitment: Bool {return self._balanceCommitment != nil}
  /// Clears the value of `balanceCommitment`. Subsequent reads from it will return its default value.
  public mutating func clearBalanceCommitment() {self._balanceCommitment = nil}

  /// The nullifier of the input note.
  public var nullifier: Data = Data()

  /// The randomized validating key for the spend authorization signature.
  public var rk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _balanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment?
}

/// Creates a new shielded note.
public struct Penumbra_Core_Transaction_V1alpha1_Output {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The authorizing data for the output.
  public var body: Penumbra_Core_Transaction_V1alpha1_OutputBody {
    get {return _body ?? Penumbra_Core_Transaction_V1alpha1_OutputBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {self._body = nil}

  /// The output proof is effecting data.
  public var proof: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _body: Penumbra_Core_Transaction_V1alpha1_OutputBody?
}

/// The body of an output description, containing only the "authorizing" data
/// included in the authorization hash used for signing, and not the "effecting"
/// data which is bound to the authorizing data by some other means.
public struct Penumbra_Core_Transaction_V1alpha1_OutputBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimal data required to scan and process the new output note.
  public var notePayload: Penumbra_Core_Crypto_V1alpha1_NotePayload {
    get {return _notePayload ?? Penumbra_Core_Crypto_V1alpha1_NotePayload()}
    set {_notePayload = newValue}
  }
  /// Returns true if `notePayload` has been explicitly set.
  public var hasNotePayload: Bool {return self._notePayload != nil}
  /// Clears the value of `notePayload`. Subsequent reads from it will return its default value.
  public mutating func clearNotePayload() {self._notePayload = nil}

  /// A commitment to the value of the output note. 32 bytes.
  public var balanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment {
    get {return _balanceCommitment ?? Penumbra_Core_Crypto_V1alpha1_BalanceCommitment()}
    set {_balanceCommitment = newValue}
  }
  /// Returns true if `balanceCommitment` has been explicitly set.
  public var hasBalanceCommitment: Bool {return self._balanceCommitment != nil}
  /// Clears the value of `balanceCommitment`. Subsequent reads from it will return its default value.
  public mutating func clearBalanceCommitment() {self._balanceCommitment = nil}

  /// An encrypted key for decrypting the memo.
  public var wrappedMemoKey: Data = Data()

  /// The key material used for note encryption, wrapped in encryption to the
  /// sender's outgoing viewing key. 80 bytes.
  public var ovkWrappedKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _notePayload: Penumbra_Core_Crypto_V1alpha1_NotePayload?
  fileprivate var _balanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment?
}

public struct Penumbra_Core_Transaction_V1alpha1_ProposalSubmit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The proposal to be submitted.
  public var proposal: Penumbra_Core_Transaction_V1alpha1_Proposal {
    get {return _proposal ?? Penumbra_Core_Transaction_V1alpha1_Proposal()}
    set {_proposal = newValue}
  }
  /// Returns true if `proposal` has been explicitly set.
  public var hasProposal: Bool {return self._proposal != nil}
  /// Clears the value of `proposal`. Subsequent reads from it will return its default value.
  public mutating func clearProposal() {self._proposal = nil}

  /// The ephemeral transparent refund address for the refund of the proposal deposit.
  public var depositRefundAddress: Penumbra_Core_Crypto_V1alpha1_Address {
    get {return _depositRefundAddress ?? Penumbra_Core_Crypto_V1alpha1_Address()}
    set {_depositRefundAddress = newValue}
  }
  /// Returns true if `depositRefundAddress` has been explicitly set.
  public var hasDepositRefundAddress: Bool {return self._depositRefundAddress != nil}
  /// Clears the value of `depositRefundAddress`. Subsequent reads from it will return its default value.
  public mutating func clearDepositRefundAddress() {self._depositRefundAddress = nil}

  /// The amount of the proposal deposit.
  public var depositAmount: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _depositAmount ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_depositAmount = newValue}
  }
  /// Returns true if `depositAmount` has been explicitly set.
  public var hasDepositAmount: Bool {return self._depositAmount != nil}
  /// Clears the value of `depositAmount`. Subsequent reads from it will return its default value.
  public mutating func clearDepositAmount() {self._depositAmount = nil}

  /// The randomized proposer key (a randomization of the proposer's spend verification key).
  public var rk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _proposal: Penumbra_Core_Transaction_V1alpha1_Proposal?
  fileprivate var _depositRefundAddress: Penumbra_Core_Crypto_V1alpha1_Address?
  fileprivate var _depositAmount: Penumbra_Core_Crypto_V1alpha1_Amount?
}

public struct Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The body of the proposal withdraw message.
  public var body: Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawBody {
    get {return _body ?? Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {self._body = nil}

  /// The signature with the randomized proposer key of the withdrawal.
  public var authSig: Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature {
    get {return _authSig ?? Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature()}
    set {_authSig = newValue}
  }
  /// Returns true if `authSig` has been explicitly set.
  public var hasAuthSig: Bool {return self._authSig != nil}
  /// Clears the value of `authSig`. Subsequent reads from it will return its default value.
  public mutating func clearAuthSig() {self._authSig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _body: Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawBody?
  fileprivate var _authSig: Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature?
}

public struct Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The proposal to be withdrawn.
  public var proposal: UInt64 = 0

  /// The reason for the proposal being withdrawn.
  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Penumbra_Core_Transaction_V1alpha1_ValidatorVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The authorizing data for the vote.
  public var body: Penumbra_Core_Transaction_V1alpha1_ValidatorVoteBody {
    get {return _body ?? Penumbra_Core_Transaction_V1alpha1_ValidatorVoteBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {self._body = nil}

  /// The vote authorization signature is effecting data.
  public var authSig: Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature {
    get {return _authSig ?? Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature()}
    set {_authSig = newValue}
  }
  /// Returns true if `authSig` has been explicitly set.
  public var hasAuthSig: Bool {return self._authSig != nil}
  /// Clears the value of `authSig`. Subsequent reads from it will return its default value.
  public mutating func clearAuthSig() {self._authSig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _body: Penumbra_Core_Transaction_V1alpha1_ValidatorVoteBody?
  fileprivate var _authSig: Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature?
}

public struct Penumbra_Core_Transaction_V1alpha1_ValidatorVoteBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The proposal being voted on.
  public var proposal: UInt64 = 0

  /// The vote.
  public var vote: Penumbra_Core_Governance_V1alpha1_Vote {
    get {return _vote ?? Penumbra_Core_Governance_V1alpha1_Vote()}
    set {_vote = newValue}
  }
  /// Returns true if `vote` has been explicitly set.
  public var hasVote: Bool {return self._vote != nil}
  /// Clears the value of `vote`. Subsequent reads from it will return its default value.
  public mutating func clearVote() {self._vote = nil}

  /// The validator identity.
  public var identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey {
    get {return _identityKey ?? Penumbra_Core_Crypto_V1alpha1_IdentityKey()}
    set {_identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  public var hasIdentityKey: Bool {return self._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  public mutating func clearIdentityKey() {self._identityKey = nil}

  /// The validator governance key.
  public var governanceKey: Penumbra_Core_Crypto_V1alpha1_GovernanceKey {
    get {return _governanceKey ?? Penumbra_Core_Crypto_V1alpha1_GovernanceKey()}
    set {_governanceKey = newValue}
  }
  /// Returns true if `governanceKey` has been explicitly set.
  public var hasGovernanceKey: Bool {return self._governanceKey != nil}
  /// Clears the value of `governanceKey`. Subsequent reads from it will return its default value.
  public mutating func clearGovernanceKey() {self._governanceKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vote: Penumbra_Core_Governance_V1alpha1_Vote?
  fileprivate var _identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey?
  fileprivate var _governanceKey: Penumbra_Core_Crypto_V1alpha1_GovernanceKey?
}

public struct Penumbra_Core_Transaction_V1alpha1_DelegatorVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The authorizing data for the vote, which is included in the authorization hash used for signing.
  public var body: Penumbra_Core_Transaction_V1alpha1_DelegatorVoteBody {
    get {return _body ?? Penumbra_Core_Transaction_V1alpha1_DelegatorVoteBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {self._body = nil}

  /// The vote authorization signature is effecting data.
  public var authSig: Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature {
    get {return _authSig ?? Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature()}
    set {_authSig = newValue}
  }
  /// Returns true if `authSig` has been explicitly set.
  public var hasAuthSig: Bool {return self._authSig != nil}
  /// Clears the value of `authSig`. Subsequent reads from it will return its default value.
  public mutating func clearAuthSig() {self._authSig = nil}

  /// The vote proof is effecting data.
  public var proof: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _body: Penumbra_Core_Transaction_V1alpha1_DelegatorVoteBody?
  fileprivate var _authSig: Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature?
}

public struct Penumbra_Core_Transaction_V1alpha1_DelegatorVoteBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The proposal being voted on.
  public var proposal: UInt64 = 0

  /// The nullifier of the input note.
  public var nullifier: Data = Data()

  /// The randomized validating key for the spend authorization signature.
  public var rk: Data = Data()

  /// A commitment to the value voted for "yes".
  ///
  /// A rational voter will place all their voting weight on one vote.
  public var yesBalanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment {
    get {return _yesBalanceCommitment ?? Penumbra_Core_Crypto_V1alpha1_BalanceCommitment()}
    set {_yesBalanceCommitment = newValue}
  }
  /// Returns true if `yesBalanceCommitment` has been explicitly set.
  public var hasYesBalanceCommitment: Bool {return self._yesBalanceCommitment != nil}
  /// Clears the value of `yesBalanceCommitment`. Subsequent reads from it will return its default value.
  public mutating func clearYesBalanceCommitment() {self._yesBalanceCommitment = nil}

  /// A commitment to the value voted for "no".
  ///
  /// A rational voter will place all their voting weight on one vote.
  public var noBalanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment {
    get {return _noBalanceCommitment ?? Penumbra_Core_Crypto_V1alpha1_BalanceCommitment()}
    set {_noBalanceCommitment = newValue}
  }
  /// Returns true if `noBalanceCommitment` has been explicitly set.
  public var hasNoBalanceCommitment: Bool {return self._noBalanceCommitment != nil}
  /// Clears the value of `noBalanceCommitment`. Subsequent reads from it will return its default value.
  public mutating func clearNoBalanceCommitment() {self._noBalanceCommitment = nil}

  /// A commitment to the value voted for "abstain".
  ///
  /// A rational voter will place all their voting weight on one vote.
  public var abstainBalanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment {
    get {return _abstainBalanceCommitment ?? Penumbra_Core_Crypto_V1alpha1_BalanceCommitment()}
    set {_abstainBalanceCommitment = newValue}
  }
  /// Returns true if `abstainBalanceCommitment` has been explicitly set.
  public var hasAbstainBalanceCommitment: Bool {return self._abstainBalanceCommitment != nil}
  /// Clears the value of `abstainBalanceCommitment`. Subsequent reads from it will return its default value.
  public mutating func clearAbstainBalanceCommitment() {self._abstainBalanceCommitment = nil}

  /// A commitment to the value voted for "no with veto".
  ///
  /// A rational voter will place all their voting weight on one vote.
  public var noWithVetoBalanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment {
    get {return _noWithVetoBalanceCommitment ?? Penumbra_Core_Crypto_V1alpha1_BalanceCommitment()}
    set {_noWithVetoBalanceCommitment = newValue}
  }
  /// Returns true if `noWithVetoBalanceCommitment` has been explicitly set.
  public var hasNoWithVetoBalanceCommitment: Bool {return self._noWithVetoBalanceCommitment != nil}
  /// Clears the value of `noWithVetoBalanceCommitment`. Subsequent reads from it will return its default value.
  public mutating func clearNoWithVetoBalanceCommitment() {self._noWithVetoBalanceCommitment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _yesBalanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment?
  fileprivate var _noBalanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment?
  fileprivate var _abstainBalanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment?
  fileprivate var _noWithVetoBalanceCommitment: Penumbra_Core_Crypto_V1alpha1_BalanceCommitment?
}

/// The data required to authorize a transaction plan.
public struct Penumbra_Core_Transaction_V1alpha1_AuthorizationData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The computed auth hash for the approved transaction plan.
  public var authHash: Penumbra_Core_Transaction_V1alpha1_AuthHash {
    get {return _authHash ?? Penumbra_Core_Transaction_V1alpha1_AuthHash()}
    set {_authHash = newValue}
  }
  /// Returns true if `authHash` has been explicitly set.
  public var hasAuthHash: Bool {return self._authHash != nil}
  /// Clears the value of `authHash`. Subsequent reads from it will return its default value.
  public mutating func clearAuthHash() {self._authHash = nil}

  /// The required spend authorizations, returned in the same order as the
  /// Spend actions in the original request.
  public var spendAuths: [Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature] = []

  /// The required withdraw proposal authorizations, returned in the same order as the
  /// ProposalWithdraw actions in the original request.
  public var withdrawProposalAuths: [Penumbra_Core_Crypto_V1alpha1_SpendAuthSignature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authHash: Penumbra_Core_Transaction_V1alpha1_AuthHash?
}

/// The data required for proving when building a transaction from a plan.
public struct Penumbra_Core_Transaction_V1alpha1_WitnessData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The anchor for the state transition proofs.
  public var anchor: Penumbra_Core_Crypto_V1alpha1_MerkleRoot {
    get {return _anchor ?? Penumbra_Core_Crypto_V1alpha1_MerkleRoot()}
    set {_anchor = newValue}
  }
  /// Returns true if `anchor` has been explicitly set.
  public var hasAnchor: Bool {return self._anchor != nil}
  /// Clears the value of `anchor`. Subsequent reads from it will return its default value.
  public mutating func clearAnchor() {self._anchor = nil}

  /// The auth paths for the notes the transaction spends, in the
  /// same order as the spends in the transaction plan.
  public var noteCommitmentProofs: [Penumbra_Core_Crypto_V1alpha1_NoteCommitmentProof] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _anchor: Penumbra_Core_Crypto_V1alpha1_MerkleRoot?
}

/// Describes a planned transaction.
public struct Penumbra_Core_Transaction_V1alpha1_TransactionPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actions: [Penumbra_Core_Transaction_V1alpha1_ActionPlan] = []

  public var expiryHeight: UInt64 = 0

  public var chainID: String = String()

  public var fee: Penumbra_Core_Crypto_V1alpha1_Fee {
    get {return _fee ?? Penumbra_Core_Crypto_V1alpha1_Fee()}
    set {_fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  public var hasFee: Bool {return self._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  public mutating func clearFee() {self._fee = nil}

  public var cluePlans: [Penumbra_Core_Transaction_V1alpha1_CluePlan] = []

  public var memoPlan: Penumbra_Core_Transaction_V1alpha1_MemoPlan {
    get {return _memoPlan ?? Penumbra_Core_Transaction_V1alpha1_MemoPlan()}
    set {_memoPlan = newValue}
  }
  /// Returns true if `memoPlan` has been explicitly set.
  public var hasMemoPlan: Bool {return self._memoPlan != nil}
  /// Clears the value of `memoPlan`. Subsequent reads from it will return its default value.
  public mutating func clearMemoPlan() {self._memoPlan = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fee: Penumbra_Core_Crypto_V1alpha1_Fee?
  fileprivate var _memoPlan: Penumbra_Core_Transaction_V1alpha1_MemoPlan?
}

/// Describes a planned transaction action.
///
/// Some transaction Actions don't have any private data and are treated as being plans
/// themselves.
public struct Penumbra_Core_Transaction_V1alpha1_ActionPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Penumbra_Core_Transaction_V1alpha1_ActionPlan.OneOf_Action?

  public var spend: Penumbra_Core_Transaction_V1alpha1_SpendPlan {
    get {
      if case .spend(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_SpendPlan()
    }
    set {action = .spend(newValue)}
  }

  public var output: Penumbra_Core_Transaction_V1alpha1_OutputPlan {
    get {
      if case .output(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_OutputPlan()
    }
    set {action = .output(newValue)}
  }

  /// We don't need any extra information (yet) to understand delegations,
  /// because we don't yet use flow encryption.
  public var delegate: Penumbra_Core_Stake_V1alpha1_Delegate {
    get {
      if case .delegate(let v)? = action {return v}
      return Penumbra_Core_Stake_V1alpha1_Delegate()
    }
    set {action = .delegate(newValue)}
  }

  /// We don't need any extra information (yet) to understand undelegations,
  /// because we don't yet use flow encryption.
  public var undelegate: Penumbra_Core_Stake_V1alpha1_Undelegate {
    get {
      if case .undelegate(let v)? = action {return v}
      return Penumbra_Core_Stake_V1alpha1_Undelegate()
    }
    set {action = .undelegate(newValue)}
  }

  /// This is just a message relayed to the chain.
  public var validatorDefinition: Penumbra_Core_Stake_V1alpha1_ValidatorDefinition {
    get {
      if case .validatorDefinition(let v)? = action {return v}
      return Penumbra_Core_Stake_V1alpha1_ValidatorDefinition()
    }
    set {action = .validatorDefinition(newValue)}
  }

  /// This is just a message relayed to the chain.
  public var ibcAction: Penumbra_Core_Ibc_V1alpha1_IbcAction {
    get {
      if case .ibcAction(let v)? = action {return v}
      return Penumbra_Core_Ibc_V1alpha1_IbcAction()
    }
    set {action = .ibcAction(newValue)}
  }

  /// Governance:
  public var proposalSubmit: Penumbra_Core_Transaction_V1alpha1_ProposalSubmit {
    get {
      if case .proposalSubmit(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_ProposalSubmit()
    }
    set {action = .proposalSubmit(newValue)}
  }

  public var proposalWithdraw: Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawPlan {
    get {
      if case .proposalWithdraw(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawPlan()
    }
    set {action = .proposalWithdraw(newValue)}
  }

  public var validatorVote: Penumbra_Core_Transaction_V1alpha1_ValidatorVote {
    get {
      if case .validatorVote(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_ValidatorVote()
    }
    set {action = .validatorVote(newValue)}
  }

  public var delegatorVote: Penumbra_Core_Transaction_V1alpha1_DelegatorVotePlan {
    get {
      if case .delegatorVote(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_DelegatorVotePlan()
    }
    set {action = .delegatorVote(newValue)}
  }

  public var positionOpen: Penumbra_Core_Dex_V1alpha1_PositionOpen {
    get {
      if case .positionOpen(let v)? = action {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionOpen()
    }
    set {action = .positionOpen(newValue)}
  }

  public var positionClose: Penumbra_Core_Dex_V1alpha1_PositionClose {
    get {
      if case .positionClose(let v)? = action {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionClose()
    }
    set {action = .positionClose(newValue)}
  }

  public var positionWithdraw: Penumbra_Core_Dex_V1alpha1_PositionWithdraw {
    get {
      if case .positionWithdraw(let v)? = action {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionWithdraw()
    }
    set {action = .positionWithdraw(newValue)}
  }

  public var positionRewardClaim: Penumbra_Core_Dex_V1alpha1_PositionRewardClaim {
    get {
      if case .positionRewardClaim(let v)? = action {return v}
      return Penumbra_Core_Dex_V1alpha1_PositionRewardClaim()
    }
    set {action = .positionRewardClaim(newValue)}
  }

  public var swap: Penumbra_Core_Transaction_V1alpha1_SwapPlan {
    get {
      if case .swap(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_SwapPlan()
    }
    set {action = .swap(newValue)}
  }

  public var swapClaim: Penumbra_Core_Transaction_V1alpha1_SwapClaimPlan {
    get {
      if case .swapClaim(let v)? = action {return v}
      return Penumbra_Core_Transaction_V1alpha1_SwapClaimPlan()
    }
    set {action = .swapClaim(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable {
    case spend(Penumbra_Core_Transaction_V1alpha1_SpendPlan)
    case output(Penumbra_Core_Transaction_V1alpha1_OutputPlan)
    /// We don't need any extra information (yet) to understand delegations,
    /// because we don't yet use flow encryption.
    case delegate(Penumbra_Core_Stake_V1alpha1_Delegate)
    /// We don't need any extra information (yet) to understand undelegations,
    /// because we don't yet use flow encryption.
    case undelegate(Penumbra_Core_Stake_V1alpha1_Undelegate)
    /// This is just a message relayed to the chain.
    case validatorDefinition(Penumbra_Core_Stake_V1alpha1_ValidatorDefinition)
    /// This is just a message relayed to the chain.
    case ibcAction(Penumbra_Core_Ibc_V1alpha1_IbcAction)
    /// Governance:
    case proposalSubmit(Penumbra_Core_Transaction_V1alpha1_ProposalSubmit)
    case proposalWithdraw(Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawPlan)
    case validatorVote(Penumbra_Core_Transaction_V1alpha1_ValidatorVote)
    case delegatorVote(Penumbra_Core_Transaction_V1alpha1_DelegatorVotePlan)
    case positionOpen(Penumbra_Core_Dex_V1alpha1_PositionOpen)
    case positionClose(Penumbra_Core_Dex_V1alpha1_PositionClose)
    case positionWithdraw(Penumbra_Core_Dex_V1alpha1_PositionWithdraw)
    case positionRewardClaim(Penumbra_Core_Dex_V1alpha1_PositionRewardClaim)
    case swap(Penumbra_Core_Transaction_V1alpha1_SwapPlan)
    case swapClaim(Penumbra_Core_Transaction_V1alpha1_SwapClaimPlan)

  #if !swift(>=4.1)
    public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_ActionPlan.OneOf_Action, rhs: Penumbra_Core_Transaction_V1alpha1_ActionPlan.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.spend, .spend): return {
        guard case .spend(let l) = lhs, case .spend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.output, .output): return {
        guard case .output(let l) = lhs, case .output(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delegate, .delegate): return {
        guard case .delegate(let l) = lhs, case .delegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.undelegate, .undelegate): return {
        guard case .undelegate(let l) = lhs, case .undelegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.validatorDefinition, .validatorDefinition): return {
        guard case .validatorDefinition(let l) = lhs, case .validatorDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ibcAction, .ibcAction): return {
        guard case .ibcAction(let l) = lhs, case .ibcAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proposalSubmit, .proposalSubmit): return {
        guard case .proposalSubmit(let l) = lhs, case .proposalSubmit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proposalWithdraw, .proposalWithdraw): return {
        guard case .proposalWithdraw(let l) = lhs, case .proposalWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.validatorVote, .validatorVote): return {
        guard case .validatorVote(let l) = lhs, case .validatorVote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delegatorVote, .delegatorVote): return {
        guard case .delegatorVote(let l) = lhs, case .delegatorVote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionOpen, .positionOpen): return {
        guard case .positionOpen(let l) = lhs, case .positionOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionClose, .positionClose): return {
        guard case .positionClose(let l) = lhs, case .positionClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionWithdraw, .positionWithdraw): return {
        guard case .positionWithdraw(let l) = lhs, case .positionWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionRewardClaim, .positionRewardClaim): return {
        guard case .positionRewardClaim(let l) = lhs, case .positionRewardClaim(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.swap, .swap): return {
        guard case .swap(let l) = lhs, case .swap(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.swapClaim, .swapClaim): return {
        guard case .swapClaim(let l) = lhs, case .swapClaim(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Describes a plan for forming a `Clue`.
public struct Penumbra_Core_Transaction_V1alpha1_CluePlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address.
  public var address: Penumbra_Core_Crypto_V1alpha1_Address {
    get {return _address ?? Penumbra_Core_Crypto_V1alpha1_Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  /// The random seed to use for the clue plan.
  public var rseed: Data = Data()

  /// The bits of precision.
  public var precisionBits: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Penumbra_Core_Crypto_V1alpha1_Address?
}

/// Describes a plan for forming a `Memo`.
public struct Penumbra_Core_Transaction_V1alpha1_MemoPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The plaintext.
  public var plaintext: Data = Data()

  /// The key to use to encrypt the memo.
  public var key: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Penumbra_Core_Transaction_V1alpha1_SpendPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The plaintext note we plan to spend.
  public var note: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _note ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  /// The position of the note we plan to spend.
  public var position: UInt64 = 0

  /// The randomizer to use for the spend.
  public var randomizer: Data = Data()

  /// The blinding factor to use for the value commitment.
  public var valueBlinding: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _note: Penumbra_Core_Crypto_V1alpha1_Note?
}

public struct Penumbra_Core_Transaction_V1alpha1_OutputPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value to send to this output.
  public var value: Penumbra_Core_Crypto_V1alpha1_Value {
    get {return _value ?? Penumbra_Core_Crypto_V1alpha1_Value()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  /// The destination address to send it to.
  public var destAddress: Penumbra_Core_Crypto_V1alpha1_Address {
    get {return _destAddress ?? Penumbra_Core_Crypto_V1alpha1_Address()}
    set {_destAddress = newValue}
  }
  /// Returns true if `destAddress` has been explicitly set.
  public var hasDestAddress: Bool {return self._destAddress != nil}
  /// Clears the value of `destAddress`. Subsequent reads from it will return its default value.
  public mutating func clearDestAddress() {self._destAddress = nil}

  /// The blinding factor to use for the new note.
  public var noteBlinding: Data = Data()

  /// The blinding factor to use for the value commitment.
  public var valueBlinding: Data = Data()

  /// The ephemeral secret key to use for the note encryption.
  public var esk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Penumbra_Core_Crypto_V1alpha1_Value?
  fileprivate var _destAddress: Penumbra_Core_Crypto_V1alpha1_Address?
}

public struct Penumbra_Core_Transaction_V1alpha1_SwapPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The plaintext version of the swap to be performed.
  public var swapPlaintext: Penumbra_Core_Dex_V1alpha1_SwapPlaintext {
    get {return _swapPlaintext ?? Penumbra_Core_Dex_V1alpha1_SwapPlaintext()}
    set {_swapPlaintext = newValue}
  }
  /// Returns true if `swapPlaintext` has been explicitly set.
  public var hasSwapPlaintext: Bool {return self._swapPlaintext != nil}
  /// Clears the value of `swapPlaintext`. Subsequent reads from it will return its default value.
  public mutating func clearSwapPlaintext() {self._swapPlaintext = nil}

  /// The blinding factor for the fee commitment. The fee in the SwapPlan is private to prevent linkability with the SwapClaim.
  public var feeBlinding: Data = Data()

  /// The blinding factor to use for the new swap NFT note.
  public var noteBlinding: Data = Data()

  /// The ephemeral secret key to use for the swap NFT note encryption.
  public var esk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _swapPlaintext: Penumbra_Core_Dex_V1alpha1_SwapPlaintext?
}

///
/// @exclude
/// Fields describing the swap NFT note to be redeemed.
public struct Penumbra_Core_Transaction_V1alpha1_SwapClaimPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The input swap NFT note to be spent.
  public var swapNftNote: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _storage._swapNftNote ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_uniqueStorage()._swapNftNote = newValue}
  }
  /// Returns true if `swapNftNote` has been explicitly set.
  public var hasSwapNftNote: Bool {return _storage._swapNftNote != nil}
  /// Clears the value of `swapNftNote`. Subsequent reads from it will return its default value.
  public mutating func clearSwapNftNote() {_uniqueStorage()._swapNftNote = nil}

  /// The position of the input swap NFT note.
  public var swapNftPosition: UInt64 {
    get {return _storage._swapNftPosition}
    set {_uniqueStorage()._swapNftPosition = newValue}
  }

  /// The plaintext version of the swap to be performed.
  public var swapPlaintext: Penumbra_Core_Dex_V1alpha1_SwapPlaintext {
    get {return _storage._swapPlaintext ?? Penumbra_Core_Dex_V1alpha1_SwapPlaintext()}
    set {_uniqueStorage()._swapPlaintext = newValue}
  }
  /// Returns true if `swapPlaintext` has been explicitly set.
  public var hasSwapPlaintext: Bool {return _storage._swapPlaintext != nil}
  /// Clears the value of `swapPlaintext`. Subsequent reads from it will return its default value.
  public mutating func clearSwapPlaintext() {_uniqueStorage()._swapPlaintext = nil}

  /// Input and output amounts for the Swap.
  public var outputData: Penumbra_Core_Dex_V1alpha1_BatchSwapOutputData {
    get {return _storage._outputData ?? Penumbra_Core_Dex_V1alpha1_BatchSwapOutputData()}
    set {_uniqueStorage()._outputData = newValue}
  }
  /// Returns true if `outputData` has been explicitly set.
  public var hasOutputData: Bool {return _storage._outputData != nil}
  /// Clears the value of `outputData`. Subsequent reads from it will return its default value.
  public mutating func clearOutputData() {_uniqueStorage()._outputData = nil}

  /// The blinding factor used for the first output note.
  public var output1Blinding: Data {
    get {return _storage._output1Blinding}
    set {_uniqueStorage()._output1Blinding = newValue}
  }

  /// The blinding factor used for the second output note.
  public var output2Blinding: Data {
    get {return _storage._output2Blinding}
    set {_uniqueStorage()._output2Blinding = newValue}
  }

  /// The ephemeral secret key used for the first output note encryption.
  public var esk1: Data {
    get {return _storage._esk1}
    set {_uniqueStorage()._esk1 = newValue}
  }

  /// The ephemeral secret key used for the second output note encryption.
  public var esk2: Data {
    get {return _storage._esk2}
    set {_uniqueStorage()._esk2 = newValue}
  }

  /// The epoch duration when the swap claim took place.
  public var epochDuration: UInt64 {
    get {return _storage._epochDuration}
    set {_uniqueStorage()._epochDuration = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The body of the proposal withdrawal.
  public var body: Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawBody {
    get {return _body ?? Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {self._body = nil}

  /// The randomizer to use for signing the proposal withdrawal.
  public var randomizer: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _body: Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawBody?
}

public struct Penumbra_Core_Transaction_V1alpha1_DelegatorVotePlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The proposal to vote on.
  public var proposal: UInt64 = 0

  /// The vote to cast.
  public var vote: Penumbra_Core_Governance_V1alpha1_Vote {
    get {return _vote ?? Penumbra_Core_Governance_V1alpha1_Vote()}
    set {_vote = newValue}
  }
  /// Returns true if `vote` has been explicitly set.
  public var hasVote: Bool {return self._vote != nil}
  /// Clears the value of `vote`. Subsequent reads from it will return its default value.
  public mutating func clearVote() {self._vote = nil}

  /// The delegation note to prove that we can vote.
  public var stakedNote: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _stakedNote ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_stakedNote = newValue}
  }
  /// Returns true if `stakedNote` has been explicitly set.
  public var hasStakedNote: Bool {return self._stakedNote != nil}
  /// Clears the value of `stakedNote`. Subsequent reads from it will return its default value.
  public mutating func clearStakedNote() {self._stakedNote = nil}

  /// The position of that delegation note.
  public var position: UInt64 = 0

  /// The randomizer to use for the proof of spend capability.
  public var randomizer: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vote: Penumbra_Core_Governance_V1alpha1_Vote?
  fileprivate var _stakedNote: Penumbra_Core_Crypto_V1alpha1_Note?
}

/// A proposal to be voted upon.
public struct Penumbra_Core_Transaction_V1alpha1_Proposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  /// A natural-language description of the effect of the proposal and its justification.
  public var description_p: String = String()

  /// The payload of the proposal.
  public var payload: Penumbra_Core_Transaction_V1alpha1_Proposal.Payload {
    get {return _payload ?? Penumbra_Core_Transaction_V1alpha1_Proposal.Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The kind of the proposal and details relevant only to that kind of proposal.
  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var payload: Penumbra_Core_Transaction_V1alpha1_Proposal.Payload.OneOf_Payload?

    /// A signaling proposal.
    public var signaling: Penumbra_Core_Transaction_V1alpha1_Proposal.Signaling {
      get {
        if case .signaling(let v)? = payload {return v}
        return Penumbra_Core_Transaction_V1alpha1_Proposal.Signaling()
      }
      set {payload = .signaling(newValue)}
    }

    /// An emergency proposal.
    public var emergency: Penumbra_Core_Transaction_V1alpha1_Proposal.Emergency {
      get {
        if case .emergency(let v)? = payload {return v}
        return Penumbra_Core_Transaction_V1alpha1_Proposal.Emergency()
      }
      set {payload = .emergency(newValue)}
    }

    /// A parameter change proposal.
    public var parameterChange: Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange {
      get {
        if case .parameterChange(let v)? = payload {return v}
        return Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange()
      }
      set {payload = .parameterChange(newValue)}
    }

    /// A DAO spend proposal.
    public var daoSpend: Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend {
      get {
        if case .daoSpend(let v)? = payload {return v}
        return Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend()
      }
      set {payload = .daoSpend(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Payload: Equatable {
      /// A signaling proposal.
      case signaling(Penumbra_Core_Transaction_V1alpha1_Proposal.Signaling)
      /// An emergency proposal.
      case emergency(Penumbra_Core_Transaction_V1alpha1_Proposal.Emergency)
      /// A parameter change proposal.
      case parameterChange(Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange)
      /// A DAO spend proposal.
      case daoSpend(Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend)

    #if !swift(>=4.1)
      public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Proposal.Payload.OneOf_Payload, rhs: Penumbra_Core_Transaction_V1alpha1_Proposal.Payload.OneOf_Payload) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.signaling, .signaling): return {
          guard case .signaling(let l) = lhs, case .signaling(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.emergency, .emergency): return {
          guard case .emergency(let l) = lhs, case .emergency(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.parameterChange, .parameterChange): return {
          guard case .parameterChange(let l) = lhs, case .parameterChange(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.daoSpend, .daoSpend): return {
          guard case .daoSpend(let l) = lhs, case .daoSpend(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// It optionally contains a reference to a commit which contains code to upgrade the chain.
  public struct Signaling {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The commit to be voted upon, if any is relevant.
    public var commit: String {
      get {return _commit ?? String()}
      set {_commit = newValue}
    }
    /// Returns true if `commit` has been explicitly set.
    public var hasCommit: Bool {return self._commit != nil}
    /// Clears the value of `commit`. Subsequent reads from it will return its default value.
    public mutating func clearCommit() {self._commit = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _commit: String?
  }

  /// An emergency proposal can be passed instantaneously by a 2/3 majority of validators, without
  /// waiting for the voting period to expire.
  ///
  /// If the boolean `halt_chain` is set to `true`, then the chain will halt immediately when the
  /// proposal is passed.
  public struct Emergency {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If `true`, the chain will halt immediately when the proposal is passed.
    public var haltChain: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A parameter change proposal describes an alteration to one or more chain parameters, which
  /// should take effect at a particular block height `effective_height` (which should be at least
  /// the height when the proposal would be passed).
  public struct ParameterChange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The height at which the change should take effect.
    public var effectiveHeight: UInt64 = 0

    /// The set of changes to chain parameters.
    public var newParameters: [Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange.SetParameter] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A single change to an individual chain parameter.
    public struct SetParameter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the parameter.
      public var parameter: String = String()

      /// Its new value, as a string (this will be parsed as appropriate for the parameter's type).
      public var value: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// A DAO spend proposal describes zero or more transactions to execute on behalf of the DAO, with
  /// access to its funds, and zero or more scheduled transactions from previous passed proposals to
  /// cancel.
  public struct DaoSpend {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The sequence of transactions to schedule for execution.
    public var scheduleTransactions: [Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.ScheduleTransaction] = []

    /// A sequence of previously-scheduled transactions to cancel before they are executed.
    public var cancelTransactions: [Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.CancelTransaction] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A transaction to be executed as a consequence of this proposal.
    ///
    /// It is permissible for there to be duplicate transactions scheduled for a given height; they
    /// will both be executed.
    public struct ScheduleTransaction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The height at which the transaction should be executed.
      public var executeAtHeight: UInt64 = 0

      /// The transaction to be executed.
      public var transaction: Penumbra_Core_Transaction_V1alpha1_TransactionPlan {
        get {return _transaction ?? Penumbra_Core_Transaction_V1alpha1_TransactionPlan()}
        set {_transaction = newValue}
      }
      /// Returns true if `transaction` has been explicitly set.
      public var hasTransaction: Bool {return self._transaction != nil}
      /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
      public mutating func clearTransaction() {self._transaction = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _transaction: Penumbra_Core_Transaction_V1alpha1_TransactionPlan?
    }

    /// A transaction to be canceled as a consequence of this proposal.
    ///
    /// If there are multiple duplicate transactions at the height, this cancels only the first.
    /// To cancel more of them, specify duplicate cancellations.
    public struct CancelTransaction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The height for which the transaction was scheduled.
      public var scheduledAtHeight: UInt64 = 0

      /// The auth hash of the transaction to cancel.
      public var authHash: Penumbra_Core_Transaction_V1alpha1_AuthHash {
        get {return _authHash ?? Penumbra_Core_Transaction_V1alpha1_AuthHash()}
        set {_authHash = newValue}
      }
      /// Returns true if `authHash` has been explicitly set.
      public var hasAuthHash: Bool {return self._authHash != nil}
      /// Clears the value of `authHash`. Subsequent reads from it will return its default value.
      public mutating func clearAuthHash() {self._authHash = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _authHash: Penumbra_Core_Transaction_V1alpha1_AuthHash?
    }

    public init() {}
  }

  public init() {}

  fileprivate var _payload: Penumbra_Core_Transaction_V1alpha1_Proposal.Payload?
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Penumbra_Core_Transaction_V1alpha1_AuthHash: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Transaction: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_TransactionBody: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Action: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Action.OneOf_Action: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_TransactionPerspective: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_PayloadKeyWithCommitment: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_NullifierWithNote: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_TransactionView: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_SpendView: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_OutputView: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_SwapView: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_SwapClaimView: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_ActionView: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_ActionView.OneOf_ActionView: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Spend: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_SpendBody: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Output: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_OutputBody: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_ProposalSubmit: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawBody: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_ValidatorVote: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_ValidatorVoteBody: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_DelegatorVote: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_DelegatorVoteBody: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_AuthorizationData: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_WitnessData: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_TransactionPlan: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_ActionPlan: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_ActionPlan.OneOf_Action: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_CluePlan: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_MemoPlan: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_SpendPlan: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_OutputPlan: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_SwapPlan: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_SwapClaimPlan: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawPlan: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_DelegatorVotePlan: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Proposal: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Proposal.Payload: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Proposal.Payload.OneOf_Payload: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Proposal.Signaling: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Proposal.Emergency: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange.SetParameter: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.ScheduleTransaction: @unchecked Sendable {}
extension Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.CancelTransaction: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "penumbra.core.transaction.v1alpha1"

extension Penumbra_Core_Transaction_V1alpha1_AuthHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthHash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inner"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.inner) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inner.isEmpty {
      try visitor.visitSingularBytesField(value: self.inner, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_AuthHash, rhs: Penumbra_Core_Transaction_V1alpha1_AuthHash) -> Bool {
    if lhs.inner != rhs.inner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .standard(proto: "binding_sig"),
    3: .same(proto: "anchor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.bindingSig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._anchor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.bindingSig.isEmpty {
      try visitor.visitSingularBytesField(value: self.bindingSig, fieldNumber: 2)
    }
    try { if let v = self._anchor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Transaction, rhs: Penumbra_Core_Transaction_V1alpha1_Transaction) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.bindingSig != rhs.bindingSig {return false}
    if lhs._anchor != rhs._anchor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_TransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actions"),
    2: .standard(proto: "expiry_height"),
    3: .standard(proto: "chain_id"),
    4: .same(proto: "fee"),
    5: .standard(proto: "fmd_clues"),
    6: .standard(proto: "encrypted_memo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.expiryHeight) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fee) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.fmdClues) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._encryptedMemo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 1)
    }
    if self.expiryHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiryHeight, fieldNumber: 2)
    }
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 3)
    }
    try { if let v = self._fee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.fmdClues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fmdClues, fieldNumber: 5)
    }
    try { if let v = self._encryptedMemo {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_TransactionBody, rhs: Penumbra_Core_Transaction_V1alpha1_TransactionBody) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.expiryHeight != rhs.expiryHeight {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs._fee != rhs._fee {return false}
    if lhs.fmdClues != rhs.fmdClues {return false}
    if lhs._encryptedMemo != rhs._encryptedMemo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spend"),
    2: .same(proto: "output"),
    3: .same(proto: "delegate"),
    4: .same(proto: "undelegate"),
    5: .same(proto: "swap"),
    6: .standard(proto: "swap_claim"),
    16: .standard(proto: "validator_definition"),
    17: .standard(proto: "ibc_action"),
    18: .standard(proto: "proposal_submit"),
    19: .standard(proto: "proposal_withdraw"),
    20: .standard(proto: "validator_vote"),
    30: .standard(proto: "position_open"),
    31: .standard(proto: "position_close"),
    32: .standard(proto: "position_withdraw"),
    34: .standard(proto: "position_reward_claim"),
    200: .standard(proto: "ics20_withdrawal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Penumbra_Core_Transaction_V1alpha1_Spend?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .spend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .spend(v)
        }
      }()
      case 2: try {
        var v: Penumbra_Core_Transaction_V1alpha1_Output?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .output(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .output(v)
        }
      }()
      case 3: try {
        var v: Penumbra_Core_Stake_V1alpha1_Delegate?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .delegate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .delegate(v)
        }
      }()
      case 4: try {
        var v: Penumbra_Core_Stake_V1alpha1_Undelegate?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .undelegate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .undelegate(v)
        }
      }()
      case 5: try {
        var v: Penumbra_Core_Dex_V1alpha1_Swap?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .swap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .swap(v)
        }
      }()
      case 6: try {
        var v: Penumbra_Core_Dex_V1alpha1_SwapClaim?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .swapClaim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .swapClaim(v)
        }
      }()
      case 16: try {
        var v: Penumbra_Core_Stake_V1alpha1_ValidatorDefinition?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .validatorDefinition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .validatorDefinition(v)
        }
      }()
      case 17: try {
        var v: Penumbra_Core_Ibc_V1alpha1_IbcAction?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .ibcAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .ibcAction(v)
        }
      }()
      case 18: try {
        var v: Penumbra_Core_Transaction_V1alpha1_ProposalSubmit?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .proposalSubmit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .proposalSubmit(v)
        }
      }()
      case 19: try {
        var v: Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .proposalWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .proposalWithdraw(v)
        }
      }()
      case 20: try {
        var v: Penumbra_Core_Transaction_V1alpha1_ValidatorVote?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .validatorVote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .validatorVote(v)
        }
      }()
      case 30: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionOpen?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .positionOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .positionOpen(v)
        }
      }()
      case 31: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionClose?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .positionClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .positionClose(v)
        }
      }()
      case 32: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionWithdraw?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .positionWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .positionWithdraw(v)
        }
      }()
      case 34: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionRewardClaim?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .positionRewardClaim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .positionRewardClaim(v)
        }
      }()
      case 200: try {
        var v: Penumbra_Core_Ibc_V1alpha1_Ics20Withdrawal?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .ics20Withdrawal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .ics20Withdrawal(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .spend?: try {
      guard case .spend(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .output?: try {
      guard case .output(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .delegate?: try {
      guard case .delegate(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .undelegate?: try {
      guard case .undelegate(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .swap?: try {
      guard case .swap(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .swapClaim?: try {
      guard case .swapClaim(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .validatorDefinition?: try {
      guard case .validatorDefinition(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .ibcAction?: try {
      guard case .ibcAction(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .proposalSubmit?: try {
      guard case .proposalSubmit(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .proposalWithdraw?: try {
      guard case .proposalWithdraw(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .validatorVote?: try {
      guard case .validatorVote(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .positionOpen?: try {
      guard case .positionOpen(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .positionClose?: try {
      guard case .positionClose(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .positionWithdraw?: try {
      guard case .positionWithdraw(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .positionRewardClaim?: try {
      guard case .positionRewardClaim(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .ics20Withdrawal?: try {
      guard case .ics20Withdrawal(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 200)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Action, rhs: Penumbra_Core_Transaction_V1alpha1_Action) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_TransactionPerspective: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionPerspective"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payload_keys"),
    2: .standard(proto: "spend_nullifiers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.payloadKeys) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.spendNullifiers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payloadKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payloadKeys, fieldNumber: 1)
    }
    if !self.spendNullifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spendNullifiers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_TransactionPerspective, rhs: Penumbra_Core_Transaction_V1alpha1_TransactionPerspective) -> Bool {
    if lhs.payloadKeys != rhs.payloadKeys {return false}
    if lhs.spendNullifiers != rhs.spendNullifiers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_PayloadKeyWithCommitment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PayloadKeyWithCommitment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payload_key"),
    2: .same(proto: "commitment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.payloadKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._commitment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.payloadKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.payloadKey, fieldNumber: 1)
    }
    try { if let v = self._commitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_PayloadKeyWithCommitment, rhs: Penumbra_Core_Transaction_V1alpha1_PayloadKeyWithCommitment) -> Bool {
    if lhs.payloadKey != rhs.payloadKey {return false}
    if lhs._commitment != rhs._commitment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_NullifierWithNote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NullifierWithNote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nullifier"),
    2: .same(proto: "note"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nullifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nullifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_NullifierWithNote, rhs: Penumbra_Core_Transaction_V1alpha1_NullifierWithNote) -> Bool {
    if lhs._nullifier != rhs._nullifier {return false}
    if lhs._note != rhs._note {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_TransactionView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_views"),
    2: .standard(proto: "expiry_height"),
    3: .standard(proto: "chain_id"),
    4: .same(proto: "fee"),
    5: .standard(proto: "fmd_clues"),
    6: .same(proto: "memo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.actionViews) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.expiryHeight) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fee) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.fmdClues) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._memo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.actionViews.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actionViews, fieldNumber: 1)
    }
    if self.expiryHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiryHeight, fieldNumber: 2)
    }
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 3)
    }
    try { if let v = self._fee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.fmdClues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fmdClues, fieldNumber: 5)
    }
    try { if let v = self._memo {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_TransactionView, rhs: Penumbra_Core_Transaction_V1alpha1_TransactionView) -> Bool {
    if lhs.actionViews != rhs.actionViews {return false}
    if lhs.expiryHeight != rhs.expiryHeight {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs._fee != rhs._fee {return false}
    if lhs.fmdClues != rhs.fmdClues {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_SpendView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpendView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spend"),
    2: .same(proto: "note"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spend) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spend {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_SpendView, rhs: Penumbra_Core_Transaction_V1alpha1_SpendView) -> Bool {
    if lhs._spend != rhs._spend {return false}
    if lhs._note != rhs._note {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_OutputView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "output"),
    2: .same(proto: "note"),
    3: .standard(proto: "payload_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._output) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.payloadKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.payloadKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.payloadKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_OutputView, rhs: Penumbra_Core_Transaction_V1alpha1_OutputView) -> Bool {
    if lhs._output != rhs._output {return false}
    if lhs._note != rhs._note {return false}
    if lhs.payloadKey != rhs.payloadKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_SwapView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "swap"),
    2: .standard(proto: "swap_nft"),
    3: .standard(proto: "swap_plaintext"),
  ]

  fileprivate class _StorageClass {
    var _swap: Penumbra_Core_Dex_V1alpha1_Swap?
    var _swapNft: Penumbra_Core_Crypto_V1alpha1_Note?
    var _swapPlaintext: Penumbra_Core_Dex_V1alpha1_SwapPlaintext?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _swap = source._swap
      _swapNft = source._swapNft
      _swapPlaintext = source._swapPlaintext
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._swap) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._swapNft) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._swapPlaintext) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._swap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._swapNft {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._swapPlaintext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_SwapView, rhs: Penumbra_Core_Transaction_V1alpha1_SwapView) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._swap != rhs_storage._swap {return false}
        if _storage._swapNft != rhs_storage._swapNft {return false}
        if _storage._swapPlaintext != rhs_storage._swapPlaintext {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_SwapClaimView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapClaimView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "swap_claim"),
    2: .standard(proto: "output_1"),
    3: .standard(proto: "output_2"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._swapClaim) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._output1) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._output2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._swapClaim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._output1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._output2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_SwapClaimView, rhs: Penumbra_Core_Transaction_V1alpha1_SwapClaimView) -> Bool {
    if lhs._swapClaim != rhs._swapClaim {return false}
    if lhs._output1 != rhs._output1 {return false}
    if lhs._output2 != rhs._output2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_ActionView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spend"),
    2: .same(proto: "output"),
    3: .same(proto: "delegate"),
    4: .same(proto: "undelegate"),
    5: .same(proto: "swap"),
    6: .standard(proto: "swap_claim"),
    16: .standard(proto: "validator_definition"),
    17: .standard(proto: "ibc_action"),
    18: .standard(proto: "proposal_submit"),
    19: .standard(proto: "proposal_withdraw"),
    20: .standard(proto: "validator_vote"),
    30: .standard(proto: "position_open"),
    31: .standard(proto: "position_close"),
    32: .standard(proto: "position_withdraw"),
    34: .standard(proto: "position_reward_claim"),
    200: .standard(proto: "ics20_withdrawal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Penumbra_Core_Transaction_V1alpha1_SpendView?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .spend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .spend(v)
        }
      }()
      case 2: try {
        var v: Penumbra_Core_Transaction_V1alpha1_OutputView?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .output(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .output(v)
        }
      }()
      case 3: try {
        var v: Penumbra_Core_Stake_V1alpha1_Delegate?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .delegate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .delegate(v)
        }
      }()
      case 4: try {
        var v: Penumbra_Core_Stake_V1alpha1_Undelegate?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .undelegate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .undelegate(v)
        }
      }()
      case 5: try {
        var v: Penumbra_Core_Transaction_V1alpha1_SwapView?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .swap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .swap(v)
        }
      }()
      case 6: try {
        var v: Penumbra_Core_Transaction_V1alpha1_SwapClaimView?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .swapClaim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .swapClaim(v)
        }
      }()
      case 16: try {
        var v: Penumbra_Core_Stake_V1alpha1_ValidatorDefinition?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .validatorDefinition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .validatorDefinition(v)
        }
      }()
      case 17: try {
        var v: Penumbra_Core_Ibc_V1alpha1_IbcAction?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .ibcAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .ibcAction(v)
        }
      }()
      case 18: try {
        var v: Penumbra_Core_Transaction_V1alpha1_ProposalSubmit?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .proposalSubmit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .proposalSubmit(v)
        }
      }()
      case 19: try {
        var v: Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .proposalWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .proposalWithdraw(v)
        }
      }()
      case 20: try {
        var v: Penumbra_Core_Transaction_V1alpha1_ValidatorVote?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .validatorVote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .validatorVote(v)
        }
      }()
      case 30: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionOpen?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .positionOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .positionOpen(v)
        }
      }()
      case 31: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionClose?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .positionClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .positionClose(v)
        }
      }()
      case 32: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionWithdraw?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .positionWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .positionWithdraw(v)
        }
      }()
      case 34: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionRewardClaim?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .positionRewardClaim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .positionRewardClaim(v)
        }
      }()
      case 200: try {
        var v: Penumbra_Core_Ibc_V1alpha1_Ics20Withdrawal?
        var hadOneofValue = false
        if let current = self.actionView {
          hadOneofValue = true
          if case .ics20Withdrawal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionView = .ics20Withdrawal(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.actionView {
    case .spend?: try {
      guard case .spend(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .output?: try {
      guard case .output(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .delegate?: try {
      guard case .delegate(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .undelegate?: try {
      guard case .undelegate(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .swap?: try {
      guard case .swap(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .swapClaim?: try {
      guard case .swapClaim(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .validatorDefinition?: try {
      guard case .validatorDefinition(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .ibcAction?: try {
      guard case .ibcAction(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .proposalSubmit?: try {
      guard case .proposalSubmit(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .proposalWithdraw?: try {
      guard case .proposalWithdraw(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .validatorVote?: try {
      guard case .validatorVote(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .positionOpen?: try {
      guard case .positionOpen(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .positionClose?: try {
      guard case .positionClose(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .positionWithdraw?: try {
      guard case .positionWithdraw(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .positionRewardClaim?: try {
      guard case .positionRewardClaim(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .ics20Withdrawal?: try {
      guard case .ics20Withdrawal(let v)? = self.actionView else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 200)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_ActionView, rhs: Penumbra_Core_Transaction_V1alpha1_ActionView) -> Bool {
    if lhs.actionView != rhs.actionView {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Spend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Spend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .standard(proto: "auth_sig"),
    3: .same(proto: "proof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authSig) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.proof) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authSig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.proof.isEmpty {
      try visitor.visitSingularBytesField(value: self.proof, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Spend, rhs: Penumbra_Core_Transaction_V1alpha1_Spend) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs._authSig != rhs._authSig {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_SpendBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpendBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "balance_commitment"),
    3: .same(proto: "nullifier"),
    4: .same(proto: "rk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._balanceCommitment) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nullifier) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.rk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._balanceCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nullifier.isEmpty {
      try visitor.visitSingularBytesField(value: self.nullifier, fieldNumber: 3)
    }
    if !self.rk.isEmpty {
      try visitor.visitSingularBytesField(value: self.rk, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_SpendBody, rhs: Penumbra_Core_Transaction_V1alpha1_SpendBody) -> Bool {
    if lhs._balanceCommitment != rhs._balanceCommitment {return false}
    if lhs.nullifier != rhs.nullifier {return false}
    if lhs.rk != rhs.rk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Output"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "proof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.proof) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.proof.isEmpty {
      try visitor.visitSingularBytesField(value: self.proof, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Output, rhs: Penumbra_Core_Transaction_V1alpha1_Output) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_OutputBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "note_payload"),
    2: .standard(proto: "balance_commitment"),
    3: .standard(proto: "wrapped_memo_key"),
    4: .standard(proto: "ovk_wrapped_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._notePayload) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._balanceCommitment) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.wrappedMemoKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.ovkWrappedKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._notePayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._balanceCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.wrappedMemoKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.wrappedMemoKey, fieldNumber: 3)
    }
    if !self.ovkWrappedKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.ovkWrappedKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_OutputBody, rhs: Penumbra_Core_Transaction_V1alpha1_OutputBody) -> Bool {
    if lhs._notePayload != rhs._notePayload {return false}
    if lhs._balanceCommitment != rhs._balanceCommitment {return false}
    if lhs.wrappedMemoKey != rhs.wrappedMemoKey {return false}
    if lhs.ovkWrappedKey != rhs.ovkWrappedKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_ProposalSubmit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProposalSubmit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposal"),
    2: .standard(proto: "deposit_refund_address"),
    3: .standard(proto: "deposit_amount"),
    4: .same(proto: "rk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._proposal) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._depositRefundAddress) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._depositAmount) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.rk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._proposal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._depositRefundAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._depositAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.rk.isEmpty {
      try visitor.visitSingularBytesField(value: self.rk, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_ProposalSubmit, rhs: Penumbra_Core_Transaction_V1alpha1_ProposalSubmit) -> Bool {
    if lhs._proposal != rhs._proposal {return false}
    if lhs._depositRefundAddress != rhs._depositRefundAddress {return false}
    if lhs._depositAmount != rhs._depositAmount {return false}
    if lhs.rk != rhs.rk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProposalWithdraw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .standard(proto: "auth_sig"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authSig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authSig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw, rhs: Penumbra_Core_Transaction_V1alpha1_ProposalWithdraw) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs._authSig != rhs._authSig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProposalWithdrawBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposal"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.proposal) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.proposal != 0 {
      try visitor.visitSingularUInt64Field(value: self.proposal, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawBody, rhs: Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawBody) -> Bool {
    if lhs.proposal != rhs.proposal {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_ValidatorVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorVote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .standard(proto: "auth_sig"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authSig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authSig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_ValidatorVote, rhs: Penumbra_Core_Transaction_V1alpha1_ValidatorVote) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs._authSig != rhs._authSig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_ValidatorVoteBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorVoteBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposal"),
    2: .same(proto: "vote"),
    3: .standard(proto: "identity_key"),
    4: .standard(proto: "governance_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.proposal) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._vote) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._identityKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._governanceKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.proposal != 0 {
      try visitor.visitSingularUInt64Field(value: self.proposal, fieldNumber: 1)
    }
    try { if let v = self._vote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._identityKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._governanceKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_ValidatorVoteBody, rhs: Penumbra_Core_Transaction_V1alpha1_ValidatorVoteBody) -> Bool {
    if lhs.proposal != rhs.proposal {return false}
    if lhs._vote != rhs._vote {return false}
    if lhs._identityKey != rhs._identityKey {return false}
    if lhs._governanceKey != rhs._governanceKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_DelegatorVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegatorVote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .standard(proto: "auth_sig"),
    3: .same(proto: "proof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authSig) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.proof) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authSig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.proof.isEmpty {
      try visitor.visitSingularBytesField(value: self.proof, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_DelegatorVote, rhs: Penumbra_Core_Transaction_V1alpha1_DelegatorVote) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs._authSig != rhs._authSig {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_DelegatorVoteBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegatorVoteBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposal"),
    3: .same(proto: "nullifier"),
    4: .same(proto: "rk"),
    5: .standard(proto: "yes_balance_commitment"),
    6: .standard(proto: "no_balance_commitment"),
    7: .standard(proto: "abstain_balance_commitment"),
    8: .standard(proto: "no_with_veto_balance_commitment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.proposal) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nullifier) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.rk) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._yesBalanceCommitment) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._noBalanceCommitment) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._abstainBalanceCommitment) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._noWithVetoBalanceCommitment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.proposal != 0 {
      try visitor.visitSingularUInt64Field(value: self.proposal, fieldNumber: 1)
    }
    if !self.nullifier.isEmpty {
      try visitor.visitSingularBytesField(value: self.nullifier, fieldNumber: 3)
    }
    if !self.rk.isEmpty {
      try visitor.visitSingularBytesField(value: self.rk, fieldNumber: 4)
    }
    try { if let v = self._yesBalanceCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._noBalanceCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._abstainBalanceCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._noWithVetoBalanceCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_DelegatorVoteBody, rhs: Penumbra_Core_Transaction_V1alpha1_DelegatorVoteBody) -> Bool {
    if lhs.proposal != rhs.proposal {return false}
    if lhs.nullifier != rhs.nullifier {return false}
    if lhs.rk != rhs.rk {return false}
    if lhs._yesBalanceCommitment != rhs._yesBalanceCommitment {return false}
    if lhs._noBalanceCommitment != rhs._noBalanceCommitment {return false}
    if lhs._abstainBalanceCommitment != rhs._abstainBalanceCommitment {return false}
    if lhs._noWithVetoBalanceCommitment != rhs._noWithVetoBalanceCommitment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_AuthorizationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthorizationData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_hash"),
    2: .standard(proto: "spend_auths"),
    3: .standard(proto: "withdraw_proposal_auths"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authHash) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.spendAuths) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.withdrawProposalAuths) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.spendAuths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spendAuths, fieldNumber: 2)
    }
    if !self.withdrawProposalAuths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.withdrawProposalAuths, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_AuthorizationData, rhs: Penumbra_Core_Transaction_V1alpha1_AuthorizationData) -> Bool {
    if lhs._authHash != rhs._authHash {return false}
    if lhs.spendAuths != rhs.spendAuths {return false}
    if lhs.withdrawProposalAuths != rhs.withdrawProposalAuths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_WitnessData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WitnessData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "anchor"),
    2: .standard(proto: "note_commitment_proofs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._anchor) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.noteCommitmentProofs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._anchor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.noteCommitmentProofs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.noteCommitmentProofs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_WitnessData, rhs: Penumbra_Core_Transaction_V1alpha1_WitnessData) -> Bool {
    if lhs._anchor != rhs._anchor {return false}
    if lhs.noteCommitmentProofs != rhs.noteCommitmentProofs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_TransactionPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionPlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actions"),
    2: .standard(proto: "expiry_height"),
    3: .standard(proto: "chain_id"),
    4: .same(proto: "fee"),
    5: .standard(proto: "clue_plans"),
    6: .standard(proto: "memo_plan"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.expiryHeight) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fee) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.cluePlans) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._memoPlan) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 1)
    }
    if self.expiryHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiryHeight, fieldNumber: 2)
    }
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 3)
    }
    try { if let v = self._fee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.cluePlans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cluePlans, fieldNumber: 5)
    }
    try { if let v = self._memoPlan {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_TransactionPlan, rhs: Penumbra_Core_Transaction_V1alpha1_TransactionPlan) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.expiryHeight != rhs.expiryHeight {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs._fee != rhs._fee {return false}
    if lhs.cluePlans != rhs.cluePlans {return false}
    if lhs._memoPlan != rhs._memoPlan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_ActionPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionPlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spend"),
    2: .same(proto: "output"),
    3: .same(proto: "delegate"),
    4: .same(proto: "undelegate"),
    16: .standard(proto: "validator_definition"),
    17: .standard(proto: "ibc_action"),
    18: .standard(proto: "proposal_submit"),
    19: .standard(proto: "proposal_withdraw"),
    20: .standard(proto: "validator_vote"),
    21: .standard(proto: "delegator_vote"),
    30: .standard(proto: "position_open"),
    31: .standard(proto: "position_close"),
    32: .standard(proto: "position_withdraw"),
    34: .standard(proto: "position_reward_claim"),
    40: .same(proto: "swap"),
    41: .standard(proto: "swap_claim"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Penumbra_Core_Transaction_V1alpha1_SpendPlan?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .spend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .spend(v)
        }
      }()
      case 2: try {
        var v: Penumbra_Core_Transaction_V1alpha1_OutputPlan?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .output(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .output(v)
        }
      }()
      case 3: try {
        var v: Penumbra_Core_Stake_V1alpha1_Delegate?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .delegate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .delegate(v)
        }
      }()
      case 4: try {
        var v: Penumbra_Core_Stake_V1alpha1_Undelegate?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .undelegate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .undelegate(v)
        }
      }()
      case 16: try {
        var v: Penumbra_Core_Stake_V1alpha1_ValidatorDefinition?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .validatorDefinition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .validatorDefinition(v)
        }
      }()
      case 17: try {
        var v: Penumbra_Core_Ibc_V1alpha1_IbcAction?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .ibcAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .ibcAction(v)
        }
      }()
      case 18: try {
        var v: Penumbra_Core_Transaction_V1alpha1_ProposalSubmit?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .proposalSubmit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .proposalSubmit(v)
        }
      }()
      case 19: try {
        var v: Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawPlan?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .proposalWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .proposalWithdraw(v)
        }
      }()
      case 20: try {
        var v: Penumbra_Core_Transaction_V1alpha1_ValidatorVote?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .validatorVote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .validatorVote(v)
        }
      }()
      case 21: try {
        var v: Penumbra_Core_Transaction_V1alpha1_DelegatorVotePlan?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .delegatorVote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .delegatorVote(v)
        }
      }()
      case 30: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionOpen?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .positionOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .positionOpen(v)
        }
      }()
      case 31: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionClose?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .positionClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .positionClose(v)
        }
      }()
      case 32: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionWithdraw?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .positionWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .positionWithdraw(v)
        }
      }()
      case 34: try {
        var v: Penumbra_Core_Dex_V1alpha1_PositionRewardClaim?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .positionRewardClaim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .positionRewardClaim(v)
        }
      }()
      case 40: try {
        var v: Penumbra_Core_Transaction_V1alpha1_SwapPlan?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .swap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .swap(v)
        }
      }()
      case 41: try {
        var v: Penumbra_Core_Transaction_V1alpha1_SwapClaimPlan?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .swapClaim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .swapClaim(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .spend?: try {
      guard case .spend(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .output?: try {
      guard case .output(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .delegate?: try {
      guard case .delegate(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .undelegate?: try {
      guard case .undelegate(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .validatorDefinition?: try {
      guard case .validatorDefinition(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .ibcAction?: try {
      guard case .ibcAction(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .proposalSubmit?: try {
      guard case .proposalSubmit(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .proposalWithdraw?: try {
      guard case .proposalWithdraw(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .validatorVote?: try {
      guard case .validatorVote(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .delegatorVote?: try {
      guard case .delegatorVote(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .positionOpen?: try {
      guard case .positionOpen(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .positionClose?: try {
      guard case .positionClose(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .positionWithdraw?: try {
      guard case .positionWithdraw(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .positionRewardClaim?: try {
      guard case .positionRewardClaim(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .swap?: try {
      guard case .swap(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .swapClaim?: try {
      guard case .swapClaim(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_ActionPlan, rhs: Penumbra_Core_Transaction_V1alpha1_ActionPlan) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_CluePlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CluePlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "rseed"),
    3: .standard(proto: "precision_bits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rseed) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.precisionBits) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rseed.isEmpty {
      try visitor.visitSingularBytesField(value: self.rseed, fieldNumber: 2)
    }
    if self.precisionBits != 0 {
      try visitor.visitSingularUInt64Field(value: self.precisionBits, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_CluePlan, rhs: Penumbra_Core_Transaction_V1alpha1_CluePlan) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.rseed != rhs.rseed {return false}
    if lhs.precisionBits != rhs.precisionBits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_MemoPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemoPlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "plaintext"),
    2: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.plaintext) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.plaintext.isEmpty {
      try visitor.visitSingularBytesField(value: self.plaintext, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_MemoPlan, rhs: Penumbra_Core_Transaction_V1alpha1_MemoPlan) -> Bool {
    if lhs.plaintext != rhs.plaintext {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_SpendPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpendPlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "note"),
    2: .same(proto: "position"),
    3: .same(proto: "randomizer"),
    4: .standard(proto: "value_blinding"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.position) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.randomizer) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.valueBlinding) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.position != 0 {
      try visitor.visitSingularUInt64Field(value: self.position, fieldNumber: 2)
    }
    if !self.randomizer.isEmpty {
      try visitor.visitSingularBytesField(value: self.randomizer, fieldNumber: 3)
    }
    if !self.valueBlinding.isEmpty {
      try visitor.visitSingularBytesField(value: self.valueBlinding, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_SpendPlan, rhs: Penumbra_Core_Transaction_V1alpha1_SpendPlan) -> Bool {
    if lhs._note != rhs._note {return false}
    if lhs.position != rhs.position {return false}
    if lhs.randomizer != rhs.randomizer {return false}
    if lhs.valueBlinding != rhs.valueBlinding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_OutputPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputPlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "dest_address"),
    3: .standard(proto: "note_blinding"),
    4: .standard(proto: "value_blinding"),
    5: .same(proto: "esk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._destAddress) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.noteBlinding) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.valueBlinding) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.esk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._destAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.noteBlinding.isEmpty {
      try visitor.visitSingularBytesField(value: self.noteBlinding, fieldNumber: 3)
    }
    if !self.valueBlinding.isEmpty {
      try visitor.visitSingularBytesField(value: self.valueBlinding, fieldNumber: 4)
    }
    if !self.esk.isEmpty {
      try visitor.visitSingularBytesField(value: self.esk, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_OutputPlan, rhs: Penumbra_Core_Transaction_V1alpha1_OutputPlan) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._destAddress != rhs._destAddress {return false}
    if lhs.noteBlinding != rhs.noteBlinding {return false}
    if lhs.valueBlinding != rhs.valueBlinding {return false}
    if lhs.esk != rhs.esk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_SwapPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapPlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "swap_plaintext"),
    5: .standard(proto: "fee_blinding"),
    7: .standard(proto: "note_blinding"),
    8: .same(proto: "esk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._swapPlaintext) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.feeBlinding) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.noteBlinding) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.esk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._swapPlaintext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.feeBlinding.isEmpty {
      try visitor.visitSingularBytesField(value: self.feeBlinding, fieldNumber: 5)
    }
    if !self.noteBlinding.isEmpty {
      try visitor.visitSingularBytesField(value: self.noteBlinding, fieldNumber: 7)
    }
    if !self.esk.isEmpty {
      try visitor.visitSingularBytesField(value: self.esk, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_SwapPlan, rhs: Penumbra_Core_Transaction_V1alpha1_SwapPlan) -> Bool {
    if lhs._swapPlaintext != rhs._swapPlaintext {return false}
    if lhs.feeBlinding != rhs.feeBlinding {return false}
    if lhs.noteBlinding != rhs.noteBlinding {return false}
    if lhs.esk != rhs.esk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_SwapClaimPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapClaimPlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "swap_nft_note"),
    2: .standard(proto: "swap_nft_position"),
    3: .standard(proto: "swap_plaintext"),
    11: .standard(proto: "output_data"),
    15: .standard(proto: "output_1_blinding"),
    16: .standard(proto: "output_2_blinding"),
    17: .standard(proto: "esk_1"),
    18: .standard(proto: "esk_2"),
    20: .standard(proto: "epoch_duration"),
  ]

  fileprivate class _StorageClass {
    var _swapNftNote: Penumbra_Core_Crypto_V1alpha1_Note?
    var _swapNftPosition: UInt64 = 0
    var _swapPlaintext: Penumbra_Core_Dex_V1alpha1_SwapPlaintext?
    var _outputData: Penumbra_Core_Dex_V1alpha1_BatchSwapOutputData?
    var _output1Blinding: Data = Data()
    var _output2Blinding: Data = Data()
    var _esk1: Data = Data()
    var _esk2: Data = Data()
    var _epochDuration: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _swapNftNote = source._swapNftNote
      _swapNftPosition = source._swapNftPosition
      _swapPlaintext = source._swapPlaintext
      _outputData = source._outputData
      _output1Blinding = source._output1Blinding
      _output2Blinding = source._output2Blinding
      _esk1 = source._esk1
      _esk2 = source._esk2
      _epochDuration = source._epochDuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._swapNftNote) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._swapNftPosition) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._swapPlaintext) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._outputData) }()
        case 15: try { try decoder.decodeSingularBytesField(value: &_storage._output1Blinding) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._output2Blinding) }()
        case 17: try { try decoder.decodeSingularBytesField(value: &_storage._esk1) }()
        case 18: try { try decoder.decodeSingularBytesField(value: &_storage._esk2) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._epochDuration) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._swapNftNote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._swapNftPosition != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._swapNftPosition, fieldNumber: 2)
      }
      try { if let v = _storage._swapPlaintext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._outputData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._output1Blinding.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._output1Blinding, fieldNumber: 15)
      }
      if !_storage._output2Blinding.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._output2Blinding, fieldNumber: 16)
      }
      if !_storage._esk1.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._esk1, fieldNumber: 17)
      }
      if !_storage._esk2.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._esk2, fieldNumber: 18)
      }
      if _storage._epochDuration != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._epochDuration, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_SwapClaimPlan, rhs: Penumbra_Core_Transaction_V1alpha1_SwapClaimPlan) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._swapNftNote != rhs_storage._swapNftNote {return false}
        if _storage._swapNftPosition != rhs_storage._swapNftPosition {return false}
        if _storage._swapPlaintext != rhs_storage._swapPlaintext {return false}
        if _storage._outputData != rhs_storage._outputData {return false}
        if _storage._output1Blinding != rhs_storage._output1Blinding {return false}
        if _storage._output2Blinding != rhs_storage._output2Blinding {return false}
        if _storage._esk1 != rhs_storage._esk1 {return false}
        if _storage._esk2 != rhs_storage._esk2 {return false}
        if _storage._epochDuration != rhs_storage._epochDuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProposalWithdrawPlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "randomizer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.randomizer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.randomizer.isEmpty {
      try visitor.visitSingularBytesField(value: self.randomizer, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawPlan, rhs: Penumbra_Core_Transaction_V1alpha1_ProposalWithdrawPlan) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.randomizer != rhs.randomizer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_DelegatorVotePlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegatorVotePlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposal"),
    2: .same(proto: "vote"),
    3: .standard(proto: "staked_note"),
    4: .same(proto: "position"),
    5: .same(proto: "randomizer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.proposal) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._vote) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stakedNote) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.position) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.randomizer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.proposal != 0 {
      try visitor.visitSingularUInt64Field(value: self.proposal, fieldNumber: 1)
    }
    try { if let v = self._vote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stakedNote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.position != 0 {
      try visitor.visitSingularUInt64Field(value: self.position, fieldNumber: 4)
    }
    if !self.randomizer.isEmpty {
      try visitor.visitSingularBytesField(value: self.randomizer, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_DelegatorVotePlan, rhs: Penumbra_Core_Transaction_V1alpha1_DelegatorVotePlan) -> Bool {
    if lhs.proposal != rhs.proposal {return false}
    if lhs._vote != rhs._vote {return false}
    if lhs._stakedNote != rhs._stakedNote {return false}
    if lhs.position != rhs.position {return false}
    if lhs.randomizer != rhs.randomizer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Proposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Proposal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Proposal, rhs: Penumbra_Core_Transaction_V1alpha1_Proposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Proposal.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Transaction_V1alpha1_Proposal.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "signaling"),
    3: .same(proto: "emergency"),
    4: .standard(proto: "parameter_change"),
    5: .standard(proto: "dao_spend"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Penumbra_Core_Transaction_V1alpha1_Proposal.Signaling?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .signaling(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .signaling(v)
        }
      }()
      case 3: try {
        var v: Penumbra_Core_Transaction_V1alpha1_Proposal.Emergency?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .emergency(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .emergency(v)
        }
      }()
      case 4: try {
        var v: Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .parameterChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .parameterChange(v)
        }
      }()
      case 5: try {
        var v: Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .daoSpend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .daoSpend(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .signaling?: try {
      guard case .signaling(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .emergency?: try {
      guard case .emergency(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .parameterChange?: try {
      guard case .parameterChange(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .daoSpend?: try {
      guard case .daoSpend(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Proposal.Payload, rhs: Penumbra_Core_Transaction_V1alpha1_Proposal.Payload) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Proposal.Signaling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Transaction_V1alpha1_Proposal.protoMessageName + ".Signaling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._commit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commit {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Proposal.Signaling, rhs: Penumbra_Core_Transaction_V1alpha1_Proposal.Signaling) -> Bool {
    if lhs._commit != rhs._commit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Proposal.Emergency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Transaction_V1alpha1_Proposal.protoMessageName + ".Emergency"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "halt_chain"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.haltChain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.haltChain != false {
      try visitor.visitSingularBoolField(value: self.haltChain, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Proposal.Emergency, rhs: Penumbra_Core_Transaction_V1alpha1_Proposal.Emergency) -> Bool {
    if lhs.haltChain != rhs.haltChain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Transaction_V1alpha1_Proposal.protoMessageName + ".ParameterChange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "effective_height"),
    2: .standard(proto: "new_parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.effectiveHeight) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.newParameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.effectiveHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.effectiveHeight, fieldNumber: 1)
    }
    if !self.newParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newParameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange, rhs: Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange) -> Bool {
    if lhs.effectiveHeight != rhs.effectiveHeight {return false}
    if lhs.newParameters != rhs.newParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange.SetParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange.protoMessageName + ".SetParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameter"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parameter) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parameter.isEmpty {
      try visitor.visitSingularStringField(value: self.parameter, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange.SetParameter, rhs: Penumbra_Core_Transaction_V1alpha1_Proposal.ParameterChange.SetParameter) -> Bool {
    if lhs.parameter != rhs.parameter {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Transaction_V1alpha1_Proposal.protoMessageName + ".DaoSpend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "schedule_transactions"),
    2: .standard(proto: "cancel_transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.scheduleTransactions) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cancelTransactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scheduleTransactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scheduleTransactions, fieldNumber: 1)
    }
    if !self.cancelTransactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cancelTransactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend, rhs: Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend) -> Bool {
    if lhs.scheduleTransactions != rhs.scheduleTransactions {return false}
    if lhs.cancelTransactions != rhs.cancelTransactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.ScheduleTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.protoMessageName + ".ScheduleTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "execute_at_height"),
    2: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.executeAtHeight) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.executeAtHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.executeAtHeight, fieldNumber: 1)
    }
    try { if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.ScheduleTransaction, rhs: Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.ScheduleTransaction) -> Bool {
    if lhs.executeAtHeight != rhs.executeAtHeight {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.CancelTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.protoMessageName + ".CancelTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scheduled_at_height"),
    2: .standard(proto: "auth_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.scheduledAtHeight) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scheduledAtHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.scheduledAtHeight, fieldNumber: 1)
    }
    try { if let v = self._authHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.CancelTransaction, rhs: Penumbra_Core_Transaction_V1alpha1_Proposal.DaoSpend.CancelTransaction) -> Bool {
    if lhs.scheduledAtHeight != rhs.scheduledAtHeight {return false}
    if lhs._authHash != rhs._authHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
