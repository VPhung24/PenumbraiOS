// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: penumbra/core/governance/v1alpha1/governance.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A vote on a proposal.
public struct Penumbra_Core_Governance_V1alpha1_Vote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The vote.
  public var vote: Penumbra_Core_Governance_V1alpha1_Vote.Vote = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A vote.
  public enum Vote: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case abstain // = 1
    case yes // = 2
    case no // = 3
    case noWithVeto // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .abstain
      case 2: self = .yes
      case 3: self = .no
      case 4: self = .noWithVeto
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .abstain: return 1
      case .yes: return 2
      case .no: return 3
      case .noWithVeto: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Penumbra_Core_Governance_V1alpha1_Vote.Vote: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Penumbra_Core_Governance_V1alpha1_Vote.Vote] = [
    .unspecified,
    .abstain,
    .yes,
    .no,
    .noWithVeto,
  ]
}

#endif  // swift(>=4.2)

/// A chain parameter that can be modified by governance.
public struct Penumbra_Core_Governance_V1alpha1_MutableChainParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier of the parameter, used for submitting change proposals.
  public var identifier: String = String()

  /// A textual description of the parameter and valid values.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The current state of a proposal.
public struct Penumbra_Core_Governance_V1alpha1_ProposalState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The state of the proposal.
  public var state: Penumbra_Core_Governance_V1alpha1_ProposalState.OneOf_State?

  public var voting: Penumbra_Core_Governance_V1alpha1_ProposalState.Voting {
    get {
      if case .voting(let v)? = state {return v}
      return Penumbra_Core_Governance_V1alpha1_ProposalState.Voting()
    }
    set {state = .voting(newValue)}
  }

  public var withdrawn: Penumbra_Core_Governance_V1alpha1_ProposalState.Withdrawn {
    get {
      if case .withdrawn(let v)? = state {return v}
      return Penumbra_Core_Governance_V1alpha1_ProposalState.Withdrawn()
    }
    set {state = .withdrawn(newValue)}
  }

  public var finished: Penumbra_Core_Governance_V1alpha1_ProposalState.Finished {
    get {
      if case .finished(let v)? = state {return v}
      return Penumbra_Core_Governance_V1alpha1_ProposalState.Finished()
    }
    set {state = .finished(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The state of the proposal.
  public enum OneOf_State: Equatable {
    case voting(Penumbra_Core_Governance_V1alpha1_ProposalState.Voting)
    case withdrawn(Penumbra_Core_Governance_V1alpha1_ProposalState.Withdrawn)
    case finished(Penumbra_Core_Governance_V1alpha1_ProposalState.Finished)

  #if !swift(>=4.1)
    public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_ProposalState.OneOf_State, rhs: Penumbra_Core_Governance_V1alpha1_ProposalState.OneOf_State) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.voting, .voting): return {
        guard case .voting(let l) = lhs, case .voting(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withdrawn, .withdrawn): return {
        guard case .withdrawn(let l) = lhs, case .withdrawn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.finished, .finished): return {
        guard case .finished(let l) = lhs, case .finished(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Voting is in progress and the proposal has not yet concluded voting or been withdrawn.
  public struct Voting {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The proposal has been withdrawn but the voting period is not yet concluded.
  public struct Withdrawn {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The reason for the withdrawal.
    public var reason: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The voting period has ended, and the proposal has been assigned an outcome.
  public struct Finished {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var outcome: Penumbra_Core_Governance_V1alpha1_ProposalOutcome {
      get {return _outcome ?? Penumbra_Core_Governance_V1alpha1_ProposalOutcome()}
      set {_outcome = newValue}
    }
    /// Returns true if `outcome` has been explicitly set.
    public var hasOutcome: Bool {return self._outcome != nil}
    /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
    public mutating func clearOutcome() {self._outcome = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _outcome: Penumbra_Core_Governance_V1alpha1_ProposalOutcome?
  }

  public init() {}
}

/// The outcome of a concluded proposal.
public struct Penumbra_Core_Governance_V1alpha1_ProposalOutcome {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var outcome: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.OneOf_Outcome?

  public var passed: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Passed {
    get {
      if case .passed(let v)? = outcome {return v}
      return Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Passed()
    }
    set {outcome = .passed(newValue)}
  }

  public var failed: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Failed {
    get {
      if case .failed(let v)? = outcome {return v}
      return Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Failed()
    }
    set {outcome = .failed(newValue)}
  }

  public var vetoed: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Vetoed {
    get {
      if case .vetoed(let v)? = outcome {return v}
      return Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Vetoed()
    }
    set {outcome = .vetoed(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Outcome: Equatable {
    case passed(Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Passed)
    case failed(Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Failed)
    case vetoed(Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Vetoed)

  #if !swift(>=4.1)
    public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.OneOf_Outcome, rhs: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.OneOf_Outcome) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.passed, .passed): return {
        guard case .passed(let l) = lhs, case .passed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.failed, .failed): return {
        guard case .failed(let l) = lhs, case .failed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vetoed, .vetoed): return {
        guard case .vetoed(let l) = lhs, case .vetoed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The proposal was passed.
  public struct Passed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The proposal did not pass.
  public struct Failed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The proposal was withdrawn during the voting period.
    public var withdrawnWithReason: String {
      get {return _withdrawnWithReason ?? String()}
      set {_withdrawnWithReason = newValue}
    }
    /// Returns true if `withdrawnWithReason` has been explicitly set.
    public var hasWithdrawnWithReason: Bool {return self._withdrawnWithReason != nil}
    /// Clears the value of `withdrawnWithReason`. Subsequent reads from it will return its default value.
    public mutating func clearWithdrawnWithReason() {self._withdrawnWithReason = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _withdrawnWithReason: String?
  }

  /// The proposal did not pass, and was vetoed.
  public struct Vetoed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The proposal was withdrawn during the voting period.
    public var withdrawnWithReason: String {
      get {return _withdrawnWithReason ?? String()}
      set {_withdrawnWithReason = newValue}
    }
    /// Returns true if `withdrawnWithReason` has been explicitly set.
    public var hasWithdrawnWithReason: Bool {return self._withdrawnWithReason != nil}
    /// Clears the value of `withdrawnWithReason`. Subsequent reads from it will return its default value.
    public mutating func clearWithdrawnWithReason() {self._withdrawnWithReason = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _withdrawnWithReason: String?
  }

  public init() {}
}

/// A list of proposal ids.
public struct Penumbra_Core_Governance_V1alpha1_ProposalList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var proposals: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Penumbra_Core_Governance_V1alpha1_Vote: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_Vote.Vote: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_MutableChainParameter: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_ProposalState: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_ProposalState.OneOf_State: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_ProposalState.Voting: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_ProposalState.Withdrawn: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_ProposalState.Finished: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_ProposalOutcome: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_ProposalOutcome.OneOf_Outcome: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Passed: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Failed: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Vetoed: @unchecked Sendable {}
extension Penumbra_Core_Governance_V1alpha1_ProposalList: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "penumbra.core.governance.v1alpha1"

extension Penumbra_Core_Governance_V1alpha1_Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vote"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.vote) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vote != .unspecified {
      try visitor.visitSingularEnumField(value: self.vote, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_Vote, rhs: Penumbra_Core_Governance_V1alpha1_Vote) -> Bool {
    if lhs.vote != rhs.vote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Governance_V1alpha1_Vote.Vote: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOTE_UNSPECIFIED"),
    1: .same(proto: "VOTE_ABSTAIN"),
    2: .same(proto: "VOTE_YES"),
    3: .same(proto: "VOTE_NO"),
    4: .same(proto: "VOTE_NO_WITH_VETO"),
  ]
}

extension Penumbra_Core_Governance_V1alpha1_MutableChainParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MutableChainParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_MutableChainParameter, rhs: Penumbra_Core_Governance_V1alpha1_MutableChainParameter) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Governance_V1alpha1_ProposalState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProposalState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "voting"),
    3: .same(proto: "withdrawn"),
    4: .same(proto: "finished"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Penumbra_Core_Governance_V1alpha1_ProposalState.Voting?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .voting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .voting(v)
        }
      }()
      case 3: try {
        var v: Penumbra_Core_Governance_V1alpha1_ProposalState.Withdrawn?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .withdrawn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .withdrawn(v)
        }
      }()
      case 4: try {
        var v: Penumbra_Core_Governance_V1alpha1_ProposalState.Finished?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .finished(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .finished(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.state {
    case .voting?: try {
      guard case .voting(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .withdrawn?: try {
      guard case .withdrawn(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .finished?: try {
      guard case .finished(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_ProposalState, rhs: Penumbra_Core_Governance_V1alpha1_ProposalState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Governance_V1alpha1_ProposalState.Voting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Governance_V1alpha1_ProposalState.protoMessageName + ".Voting"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_ProposalState.Voting, rhs: Penumbra_Core_Governance_V1alpha1_ProposalState.Voting) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Governance_V1alpha1_ProposalState.Withdrawn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Governance_V1alpha1_ProposalState.protoMessageName + ".Withdrawn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_ProposalState.Withdrawn, rhs: Penumbra_Core_Governance_V1alpha1_ProposalState.Withdrawn) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Governance_V1alpha1_ProposalState.Finished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Governance_V1alpha1_ProposalState.protoMessageName + ".Finished"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outcome"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_ProposalState.Finished, rhs: Penumbra_Core_Governance_V1alpha1_ProposalState.Finished) -> Bool {
    if lhs._outcome != rhs._outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Governance_V1alpha1_ProposalOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProposalOutcome"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "passed"),
    2: .same(proto: "failed"),
    3: .same(proto: "vetoed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Passed?
        var hadOneofValue = false
        if let current = self.outcome {
          hadOneofValue = true
          if case .passed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.outcome = .passed(v)
        }
      }()
      case 2: try {
        var v: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Failed?
        var hadOneofValue = false
        if let current = self.outcome {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.outcome = .failed(v)
        }
      }()
      case 3: try {
        var v: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Vetoed?
        var hadOneofValue = false
        if let current = self.outcome {
          hadOneofValue = true
          if case .vetoed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.outcome = .vetoed(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.outcome {
    case .passed?: try {
      guard case .passed(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .vetoed?: try {
      guard case .vetoed(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_ProposalOutcome, rhs: Penumbra_Core_Governance_V1alpha1_ProposalOutcome) -> Bool {
    if lhs.outcome != rhs.outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Passed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Governance_V1alpha1_ProposalOutcome.protoMessageName + ".Passed"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Passed, rhs: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Passed) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Failed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Governance_V1alpha1_ProposalOutcome.protoMessageName + ".Failed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "withdrawn_with_reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._withdrawnWithReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._withdrawnWithReason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Failed, rhs: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Failed) -> Bool {
    if lhs._withdrawnWithReason != rhs._withdrawnWithReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Vetoed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Penumbra_Core_Governance_V1alpha1_ProposalOutcome.protoMessageName + ".Vetoed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "withdrawn_with_reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._withdrawnWithReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._withdrawnWithReason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Vetoed, rhs: Penumbra_Core_Governance_V1alpha1_ProposalOutcome.Vetoed) -> Bool {
    if lhs._withdrawnWithReason != rhs._withdrawnWithReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Governance_V1alpha1_ProposalList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProposalList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposals"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.proposals) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.proposals.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.proposals, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Governance_V1alpha1_ProposalList, rhs: Penumbra_Core_Governance_V1alpha1_ProposalList) -> Bool {
    if lhs.proposals != rhs.proposals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
