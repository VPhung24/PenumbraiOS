// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: penumbra/core/stake/v1alpha1/stake.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes a validator's configuration data.
public struct Penumbra_Core_Stake_V1alpha1_Validator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The validator's identity verification key.
  public var identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey {
    get {return _identityKey ?? Penumbra_Core_Crypto_V1alpha1_IdentityKey()}
    set {_identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  public var hasIdentityKey: Bool {return self._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  public mutating func clearIdentityKey() {self._identityKey = nil}

  /// The validator's consensus pubkey for use in Tendermint (Ed25519).
  public var consensusKey: Data = Data()

  /// The validator's (human-readable) name.
  public var name: String = String()

  /// The validator's website.
  public var website: String = String()

  /// The validator's description.
  public var description_p: String = String()

  /// Whether the validator is enabled or not.
  ///
  /// Disabled validators cannot be delegated to, and immediately begin unbonding.
  public var enabled: Bool = false

  /// A list of funding streams describing the validator's commission.
  public var fundingStreams: [Penumbra_Core_Stake_V1alpha1_FundingStream] = []

  /// The sequence number determines which validator data takes priority, and
  /// prevents replay attacks.  The chain only accepts new validator definitions
  /// with increasing sequence numbers.
  public var sequenceNumber: UInt32 = 0

  /// The validator's governance key.
  public var governanceKey: Penumbra_Core_Crypto_V1alpha1_GovernanceKey {
    get {return _governanceKey ?? Penumbra_Core_Crypto_V1alpha1_GovernanceKey()}
    set {_governanceKey = newValue}
  }
  /// Returns true if `governanceKey` has been explicitly set.
  public var hasGovernanceKey: Bool {return self._governanceKey != nil}
  /// Clears the value of `governanceKey`. Subsequent reads from it will return its default value.
  public mutating func clearGovernanceKey() {self._governanceKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey?
  fileprivate var _governanceKey: Penumbra_Core_Crypto_V1alpha1_GovernanceKey?
}

/// For storing the list of keys of known validators.
public struct Penumbra_Core_Stake_V1alpha1_ValidatorList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var validatorKeys: [Penumbra_Core_Crypto_V1alpha1_IdentityKey] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A portion of a validator's commission.
public struct Penumbra_Core_Stake_V1alpha1_FundingStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The destination address for the funding stream.
  public var address: String = String()

  /// The portion of the staking reward for the entire delegation pool
  /// allocated to this funding stream, specified in basis points.
  public var rateBps: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes the reward and exchange rates and voting power for a validator in some epoch.
public struct Penumbra_Core_Stake_V1alpha1_RateData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey {
    get {return _identityKey ?? Penumbra_Core_Crypto_V1alpha1_IdentityKey()}
    set {_identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  public var hasIdentityKey: Bool {return self._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  public mutating func clearIdentityKey() {self._identityKey = nil}

  public var epochIndex: UInt64 = 0

  public var validatorRewardRate: UInt64 = 0

  public var validatorExchangeRate: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey?
}

/// Describes the base reward and exchange rates in some epoch.
public struct Penumbra_Core_Stake_V1alpha1_BaseRateData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var epochIndex: UInt64 = 0

  public var baseRewardRate: UInt64 = 0

  public var baseExchangeRate: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes the current state of a validator on-chain
public struct Penumbra_Core_Stake_V1alpha1_ValidatorStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey {
    get {return _identityKey ?? Penumbra_Core_Crypto_V1alpha1_IdentityKey()}
    set {_identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  public var hasIdentityKey: Bool {return self._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  public mutating func clearIdentityKey() {self._identityKey = nil}

  public var state: Penumbra_Core_Stake_V1alpha1_ValidatorState {
    get {return _state ?? Penumbra_Core_Stake_V1alpha1_ValidatorState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var votingPower: UInt64 = 0

  public var bondingState: Penumbra_Core_Stake_V1alpha1_BondingState {
    get {return _bondingState ?? Penumbra_Core_Stake_V1alpha1_BondingState()}
    set {_bondingState = newValue}
  }
  /// Returns true if `bondingState` has been explicitly set.
  public var hasBondingState: Bool {return self._bondingState != nil}
  /// Clears the value of `bondingState`. Subsequent reads from it will return its default value.
  public mutating func clearBondingState() {self._bondingState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey?
  fileprivate var _state: Penumbra_Core_Stake_V1alpha1_ValidatorState?
  fileprivate var _bondingState: Penumbra_Core_Stake_V1alpha1_BondingState?
}

/// Describes the unbonding state of a validator's stake pool.
public struct Penumbra_Core_Stake_V1alpha1_BondingState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var state: Penumbra_Core_Stake_V1alpha1_BondingState.BondingStateEnum = .unspecified

  public var unbondingEpoch: UInt64 {
    get {return _unbondingEpoch ?? 0}
    set {_unbondingEpoch = newValue}
  }
  /// Returns true if `unbondingEpoch` has been explicitly set.
  public var hasUnbondingEpoch: Bool {return self._unbondingEpoch != nil}
  /// Clears the value of `unbondingEpoch`. Subsequent reads from it will return its default value.
  public mutating func clearUnbondingEpoch() {self._unbondingEpoch = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum BondingStateEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case bonded // = 1
    case unbonding // = 2
    case unbonded // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .bonded
      case 2: self = .unbonding
      case 3: self = .unbonded
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .bonded: return 1
      case .unbonding: return 2
      case .unbonded: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _unbondingEpoch: UInt64?
}

#if swift(>=4.2)

extension Penumbra_Core_Stake_V1alpha1_BondingState.BondingStateEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Penumbra_Core_Stake_V1alpha1_BondingState.BondingStateEnum] = [
    .unspecified,
    .bonded,
    .unbonding,
    .unbonded,
  ]
}

#endif  // swift(>=4.2)

/// Describes the state of a validator
public struct Penumbra_Core_Stake_V1alpha1_ValidatorState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var state: Penumbra_Core_Stake_V1alpha1_ValidatorState.ValidatorStateEnum = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ValidatorStateEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case inactive // = 1
    case active // = 2
    case jailed // = 3
    case tombstoned // = 4
    case disabled // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .inactive
      case 2: self = .active
      case 3: self = .jailed
      case 4: self = .tombstoned
      case 5: self = .disabled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .inactive: return 1
      case .active: return 2
      case .jailed: return 3
      case .tombstoned: return 4
      case .disabled: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Penumbra_Core_Stake_V1alpha1_ValidatorState.ValidatorStateEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Penumbra_Core_Stake_V1alpha1_ValidatorState.ValidatorStateEnum] = [
    .unspecified,
    .inactive,
    .active,
    .jailed,
    .tombstoned,
    .disabled,
  ]
}

#endif  // swift(>=4.2)

/// Combines all validator info into a single packet.
public struct Penumbra_Core_Stake_V1alpha1_ValidatorInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var validator: Penumbra_Core_Stake_V1alpha1_Validator {
    get {return _storage._validator ?? Penumbra_Core_Stake_V1alpha1_Validator()}
    set {_uniqueStorage()._validator = newValue}
  }
  /// Returns true if `validator` has been explicitly set.
  public var hasValidator: Bool {return _storage._validator != nil}
  /// Clears the value of `validator`. Subsequent reads from it will return its default value.
  public mutating func clearValidator() {_uniqueStorage()._validator = nil}

  public var status: Penumbra_Core_Stake_V1alpha1_ValidatorStatus {
    get {return _storage._status ?? Penumbra_Core_Stake_V1alpha1_ValidatorStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var rateData: Penumbra_Core_Stake_V1alpha1_RateData {
    get {return _storage._rateData ?? Penumbra_Core_Stake_V1alpha1_RateData()}
    set {_uniqueStorage()._rateData = newValue}
  }
  /// Returns true if `rateData` has been explicitly set.
  public var hasRateData: Bool {return _storage._rateData != nil}
  /// Clears the value of `rateData`. Subsequent reads from it will return its default value.
  public mutating func clearRateData() {_uniqueStorage()._rateData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A transaction action (re)defining a validator.
public struct Penumbra_Core_Stake_V1alpha1_ValidatorDefinition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The configuration data for the validator.
  public var validator: Penumbra_Core_Stake_V1alpha1_Validator {
    get {return _validator ?? Penumbra_Core_Stake_V1alpha1_Validator()}
    set {_validator = newValue}
  }
  /// Returns true if `validator` has been explicitly set.
  public var hasValidator: Bool {return self._validator != nil}
  /// Clears the value of `validator`. Subsequent reads from it will return its default value.
  public mutating func clearValidator() {self._validator = nil}

  /// A signature by the validator's identity key over the validator data.
  public var authSig: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _validator: Penumbra_Core_Stake_V1alpha1_Validator?
}

/// A transaction action adding stake to a validator's delegation pool.
public struct Penumbra_Core_Stake_V1alpha1_Delegate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity key of the validator to delegate to.
  public var validatorIdentity: Penumbra_Core_Crypto_V1alpha1_IdentityKey {
    get {return _validatorIdentity ?? Penumbra_Core_Crypto_V1alpha1_IdentityKey()}
    set {_validatorIdentity = newValue}
  }
  /// Returns true if `validatorIdentity` has been explicitly set.
  public var hasValidatorIdentity: Bool {return self._validatorIdentity != nil}
  /// Clears the value of `validatorIdentity`. Subsequent reads from it will return its default value.
  public mutating func clearValidatorIdentity() {self._validatorIdentity = nil}

  /// The index of the epoch in which this delegation was performed.
  /// The delegation takes effect in the next epoch.
  public var epochIndex: UInt64 = 0

  /// The delegation amount, in units of unbonded stake.
  /// TODO: use flow aggregation to hide this, replacing it with bytes amount_ciphertext;
  public var unbondedAmount: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _unbondedAmount ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_unbondedAmount = newValue}
  }
  /// Returns true if `unbondedAmount` has been explicitly set.
  public var hasUnbondedAmount: Bool {return self._unbondedAmount != nil}
  /// Clears the value of `unbondedAmount`. Subsequent reads from it will return its default value.
  public mutating func clearUnbondedAmount() {self._unbondedAmount = nil}

  /// The amount of delegation tokens produced by this action.
  ///
  /// This is implied by the validator's exchange rate in the specified epoch
  /// (and should be checked in transaction validation!), but including it allows
  /// stateless verification that the transaction is internally consistent.
  public var delegationAmount: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _delegationAmount ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_delegationAmount = newValue}
  }
  /// Returns true if `delegationAmount` has been explicitly set.
  public var hasDelegationAmount: Bool {return self._delegationAmount != nil}
  /// Clears the value of `delegationAmount`. Subsequent reads from it will return its default value.
  public mutating func clearDelegationAmount() {self._delegationAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _validatorIdentity: Penumbra_Core_Crypto_V1alpha1_IdentityKey?
  fileprivate var _unbondedAmount: Penumbra_Core_Crypto_V1alpha1_Amount?
  fileprivate var _delegationAmount: Penumbra_Core_Crypto_V1alpha1_Amount?
}

/// A transaction action withdrawing stake from a validator's delegation pool.
public struct Penumbra_Core_Stake_V1alpha1_Undelegate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity key of the validator to undelegate from.
  public var validatorIdentity: Penumbra_Core_Crypto_V1alpha1_IdentityKey {
    get {return _validatorIdentity ?? Penumbra_Core_Crypto_V1alpha1_IdentityKey()}
    set {_validatorIdentity = newValue}
  }
  /// Returns true if `validatorIdentity` has been explicitly set.
  public var hasValidatorIdentity: Bool {return self._validatorIdentity != nil}
  /// Clears the value of `validatorIdentity`. Subsequent reads from it will return its default value.
  public mutating func clearValidatorIdentity() {self._validatorIdentity = nil}

  /// The index of the epoch in which this undelegation was performed.
  public var epochIndex: UInt64 = 0

  /// The amount to undelegate, in units of unbonded stake.
  public var unbondedAmount: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _unbondedAmount ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_unbondedAmount = newValue}
  }
  /// Returns true if `unbondedAmount` has been explicitly set.
  public var hasUnbondedAmount: Bool {return self._unbondedAmount != nil}
  /// Clears the value of `unbondedAmount`. Subsequent reads from it will return its default value.
  public mutating func clearUnbondedAmount() {self._unbondedAmount = nil}

  /// The amount of delegation tokens consumed by this action.
  ///
  /// This is implied by the validator's exchange rate in the specified epoch
  /// (and should be checked in transaction validation!), but including it allows
  /// stateless verification that the transaction is internally consistent.
  public var delegationAmount: Penumbra_Core_Crypto_V1alpha1_Amount {
    get {return _delegationAmount ?? Penumbra_Core_Crypto_V1alpha1_Amount()}
    set {_delegationAmount = newValue}
  }
  /// Returns true if `delegationAmount` has been explicitly set.
  public var hasDelegationAmount: Bool {return self._delegationAmount != nil}
  /// Clears the value of `delegationAmount`. Subsequent reads from it will return its default value.
  public mutating func clearDelegationAmount() {self._delegationAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _validatorIdentity: Penumbra_Core_Crypto_V1alpha1_IdentityKey?
  fileprivate var _unbondedAmount: Penumbra_Core_Crypto_V1alpha1_Amount?
  fileprivate var _delegationAmount: Penumbra_Core_Crypto_V1alpha1_Amount?
}

/// A list of pending delegations and undelegations.
public struct Penumbra_Core_Stake_V1alpha1_DelegationChanges {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var delegations: [Penumbra_Core_Stake_V1alpha1_Delegate] = []

  public var undelegations: [Penumbra_Core_Stake_V1alpha1_Undelegate] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Track's a validator's uptime.
public struct Penumbra_Core_Stake_V1alpha1_Uptime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var asOfBlockHeight: UInt64 = 0

  public var windowLen: UInt32 = 0

  public var bitvec: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Tracks our view of Tendermint's view of the validator set, so we can keep it
/// from getting confused.
public struct Penumbra_Core_Stake_V1alpha1_CurrentConsensusKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consensusKeys: [Penumbra_Core_Crypto_V1alpha1_ConsensusKey] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Penumbra_Core_Stake_V1alpha1_Validator: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_ValidatorList: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_FundingStream: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_RateData: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_BaseRateData: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_ValidatorStatus: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_BondingState: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_BondingState.BondingStateEnum: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_ValidatorState: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_ValidatorState.ValidatorStateEnum: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_ValidatorInfo: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_ValidatorDefinition: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_Delegate: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_Undelegate: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_DelegationChanges: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_Uptime: @unchecked Sendable {}
extension Penumbra_Core_Stake_V1alpha1_CurrentConsensusKeys: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "penumbra.core.stake.v1alpha1"

extension Penumbra_Core_Stake_V1alpha1_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Validator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "identity_key"),
    2: .standard(proto: "consensus_key"),
    3: .same(proto: "name"),
    4: .same(proto: "website"),
    5: .same(proto: "description"),
    8: .same(proto: "enabled"),
    6: .standard(proto: "funding_streams"),
    7: .standard(proto: "sequence_number"),
    9: .standard(proto: "governance_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identityKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.consensusKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.website) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.fundingStreams) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.sequenceNumber) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._governanceKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identityKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.consensusKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.consensusKey, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.website.isEmpty {
      try visitor.visitSingularStringField(value: self.website, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.fundingStreams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fundingStreams, fieldNumber: 6)
    }
    if self.sequenceNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequenceNumber, fieldNumber: 7)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 8)
    }
    try { if let v = self._governanceKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_Validator, rhs: Penumbra_Core_Stake_V1alpha1_Validator) -> Bool {
    if lhs._identityKey != rhs._identityKey {return false}
    if lhs.consensusKey != rhs.consensusKey {return false}
    if lhs.name != rhs.name {return false}
    if lhs.website != rhs.website {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.fundingStreams != rhs.fundingStreams {return false}
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs._governanceKey != rhs._governanceKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_ValidatorList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.validatorKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validatorKeys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_ValidatorList, rhs: Penumbra_Core_Stake_V1alpha1_ValidatorList) -> Bool {
    if lhs.validatorKeys != rhs.validatorKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_FundingStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FundingStream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "rate_bps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.rateBps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.rateBps != 0 {
      try visitor.visitSingularUInt32Field(value: self.rateBps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_FundingStream, rhs: Penumbra_Core_Stake_V1alpha1_FundingStream) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.rateBps != rhs.rateBps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_RateData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RateData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "identity_key"),
    2: .standard(proto: "epoch_index"),
    4: .standard(proto: "validator_reward_rate"),
    5: .standard(proto: "validator_exchange_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identityKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.epochIndex) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.validatorRewardRate) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.validatorExchangeRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identityKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.epochIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochIndex, fieldNumber: 2)
    }
    if self.validatorRewardRate != 0 {
      try visitor.visitSingularUInt64Field(value: self.validatorRewardRate, fieldNumber: 4)
    }
    if self.validatorExchangeRate != 0 {
      try visitor.visitSingularUInt64Field(value: self.validatorExchangeRate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_RateData, rhs: Penumbra_Core_Stake_V1alpha1_RateData) -> Bool {
    if lhs._identityKey != rhs._identityKey {return false}
    if lhs.epochIndex != rhs.epochIndex {return false}
    if lhs.validatorRewardRate != rhs.validatorRewardRate {return false}
    if lhs.validatorExchangeRate != rhs.validatorExchangeRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_BaseRateData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BaseRateData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_index"),
    2: .standard(proto: "base_reward_rate"),
    3: .standard(proto: "base_exchange_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochIndex) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.baseRewardRate) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.baseExchangeRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochIndex, fieldNumber: 1)
    }
    if self.baseRewardRate != 0 {
      try visitor.visitSingularUInt64Field(value: self.baseRewardRate, fieldNumber: 2)
    }
    if self.baseExchangeRate != 0 {
      try visitor.visitSingularUInt64Field(value: self.baseExchangeRate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_BaseRateData, rhs: Penumbra_Core_Stake_V1alpha1_BaseRateData) -> Bool {
    if lhs.epochIndex != rhs.epochIndex {return false}
    if lhs.baseRewardRate != rhs.baseRewardRate {return false}
    if lhs.baseExchangeRate != rhs.baseExchangeRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_ValidatorStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "identity_key"),
    2: .same(proto: "state"),
    3: .standard(proto: "voting_power"),
    4: .standard(proto: "bonding_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identityKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.votingPower) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._bondingState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identityKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.votingPower != 0 {
      try visitor.visitSingularUInt64Field(value: self.votingPower, fieldNumber: 3)
    }
    try { if let v = self._bondingState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_ValidatorStatus, rhs: Penumbra_Core_Stake_V1alpha1_ValidatorStatus) -> Bool {
    if lhs._identityKey != rhs._identityKey {return false}
    if lhs._state != rhs._state {return false}
    if lhs.votingPower != rhs.votingPower {return false}
    if lhs._bondingState != rhs._bondingState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_BondingState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BondingState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "unbonding_epoch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._unbondingEpoch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try { if let v = self._unbondingEpoch {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_BondingState, rhs: Penumbra_Core_Stake_V1alpha1_BondingState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs._unbondingEpoch != rhs._unbondingEpoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_BondingState.BondingStateEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BONDING_STATE_ENUM_UNSPECIFIED"),
    1: .same(proto: "BONDING_STATE_ENUM_BONDED"),
    2: .same(proto: "BONDING_STATE_ENUM_UNBONDING"),
    3: .same(proto: "BONDING_STATE_ENUM_UNBONDED"),
  ]
}

extension Penumbra_Core_Stake_V1alpha1_ValidatorState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_ValidatorState, rhs: Penumbra_Core_Stake_V1alpha1_ValidatorState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_ValidatorState.ValidatorStateEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VALIDATOR_STATE_ENUM_UNSPECIFIED"),
    1: .same(proto: "VALIDATOR_STATE_ENUM_INACTIVE"),
    2: .same(proto: "VALIDATOR_STATE_ENUM_ACTIVE"),
    3: .same(proto: "VALIDATOR_STATE_ENUM_JAILED"),
    4: .same(proto: "VALIDATOR_STATE_ENUM_TOMBSTONED"),
    5: .same(proto: "VALIDATOR_STATE_ENUM_DISABLED"),
  ]
}

extension Penumbra_Core_Stake_V1alpha1_ValidatorInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    2: .same(proto: "status"),
    3: .standard(proto: "rate_data"),
  ]

  fileprivate class _StorageClass {
    var _validator: Penumbra_Core_Stake_V1alpha1_Validator?
    var _status: Penumbra_Core_Stake_V1alpha1_ValidatorStatus?
    var _rateData: Penumbra_Core_Stake_V1alpha1_RateData?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _validator = source._validator
      _status = source._status
      _rateData = source._rateData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._validator) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._rateData) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._validator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rateData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_ValidatorInfo, rhs: Penumbra_Core_Stake_V1alpha1_ValidatorInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._validator != rhs_storage._validator {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._rateData != rhs_storage._rateData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_ValidatorDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorDefinition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    2: .standard(proto: "auth_sig"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._validator) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.authSig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._validator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.authSig.isEmpty {
      try visitor.visitSingularBytesField(value: self.authSig, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_ValidatorDefinition, rhs: Penumbra_Core_Stake_V1alpha1_ValidatorDefinition) -> Bool {
    if lhs._validator != rhs._validator {return false}
    if lhs.authSig != rhs.authSig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_Delegate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Delegate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_identity"),
    2: .standard(proto: "epoch_index"),
    3: .standard(proto: "unbonded_amount"),
    4: .standard(proto: "delegation_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._validatorIdentity) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.epochIndex) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._unbondedAmount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._delegationAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._validatorIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.epochIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochIndex, fieldNumber: 2)
    }
    try { if let v = self._unbondedAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._delegationAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_Delegate, rhs: Penumbra_Core_Stake_V1alpha1_Delegate) -> Bool {
    if lhs._validatorIdentity != rhs._validatorIdentity {return false}
    if lhs.epochIndex != rhs.epochIndex {return false}
    if lhs._unbondedAmount != rhs._unbondedAmount {return false}
    if lhs._delegationAmount != rhs._delegationAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_Undelegate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Undelegate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_identity"),
    2: .standard(proto: "epoch_index"),
    3: .standard(proto: "unbonded_amount"),
    4: .standard(proto: "delegation_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._validatorIdentity) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.epochIndex) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._unbondedAmount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._delegationAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._validatorIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.epochIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochIndex, fieldNumber: 2)
    }
    try { if let v = self._unbondedAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._delegationAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_Undelegate, rhs: Penumbra_Core_Stake_V1alpha1_Undelegate) -> Bool {
    if lhs._validatorIdentity != rhs._validatorIdentity {return false}
    if lhs.epochIndex != rhs.epochIndex {return false}
    if lhs._unbondedAmount != rhs._unbondedAmount {return false}
    if lhs._delegationAmount != rhs._delegationAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_DelegationChanges: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegationChanges"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delegations"),
    2: .same(proto: "undelegations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.delegations) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.undelegations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.delegations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.delegations, fieldNumber: 1)
    }
    if !self.undelegations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.undelegations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_DelegationChanges, rhs: Penumbra_Core_Stake_V1alpha1_DelegationChanges) -> Bool {
    if lhs.delegations != rhs.delegations {return false}
    if lhs.undelegations != rhs.undelegations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_Uptime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Uptime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_of_block_height"),
    2: .standard(proto: "window_len"),
    3: .same(proto: "bitvec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.asOfBlockHeight) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.windowLen) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.bitvec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.asOfBlockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.asOfBlockHeight, fieldNumber: 1)
    }
    if self.windowLen != 0 {
      try visitor.visitSingularUInt32Field(value: self.windowLen, fieldNumber: 2)
    }
    if !self.bitvec.isEmpty {
      try visitor.visitSingularBytesField(value: self.bitvec, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_Uptime, rhs: Penumbra_Core_Stake_V1alpha1_Uptime) -> Bool {
    if lhs.asOfBlockHeight != rhs.asOfBlockHeight {return false}
    if lhs.windowLen != rhs.windowLen {return false}
    if lhs.bitvec != rhs.bitvec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_Core_Stake_V1alpha1_CurrentConsensusKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CurrentConsensusKeys"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consensus_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.consensusKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.consensusKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.consensusKeys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Penumbra_Core_Stake_V1alpha1_CurrentConsensusKeys, rhs: Penumbra_Core_Stake_V1alpha1_CurrentConsensusKeys) -> Bool {
    if lhs.consensusKeys != rhs.consensusKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
